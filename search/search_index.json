{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Definitely Not Java","text":"<p>Java is a high-level, class-based, object-oriented programming language and platform designed for portability: Java source is compiled to bytecode that runs on the Java Virtual Machine (JVM), allowing the same program to run on different operating systems that have a compatible JVM. </p> <p>The language was originally created at Sun Microsystems and is now implemented and distributed through projects and vendors such as OpenJDK, Oracle, and Eclipse Adoptium.</p>"},{"location":"#java-installation","title":"Java installation","text":"<ul> <li>Official OpenJDK</li> <li>Oracle JDK downloads</li> <li>Eclipse Adoptium (Temurin builds)</li> </ul> <p>Choose a distribution and the correct installer for your platform (Windows/macOS/Linux). </p>"},{"location":"#java-compiler-javac","title":"Java compiler <code>javac</code>","text":"<ul> <li><code>javac</code> translates Java source files (<code>.java</code>) into Java bytecode class files (<code>.class</code>) that the JVM can execute.</li> <li>Typical usage: <pre><code>javac Hello.java    # produces Hello.class\njava Hello          # runs the compiled bytecode on the JVM\n</code></pre></li> </ul> <p>This repository is inspired by CS2030S (School of Computing, National University of Singapore).</p>"},{"location":"01-compiler/","title":"Program and Compiler","text":""},{"location":"01-compiler/#software-programs","title":"Software Programs","text":"<ul> <li>A program is a collection of data variables and instructions</li> <li>Programs are written in programming languages using keywords, symbols, and names</li> <li>Programming languages provide higher level abstraction for complex instructions</li> <li>Programming languages are used to communicate instructions to a computer.</li> </ul>"},{"location":"01-compiler/#compiler-and-interpreter-execution-process","title":"Compiler and Interpreter Execution Process","text":"<ul> <li>Java compiler (<code>javac</code>) compiles source code (.java) into bytecode (.class)</li> <li>Compilation:   <pre><code>javac Hello.java    # compile Hello.java\n</code></pre></li> <li>JVM (<code>java</code>) executes the bytecode by translating it into machine code</li> <li>Execution:   <pre><code> java Hello         # runs the program\n</code></pre> <p>Notes: Launch Single-File Source-Code Programs allows running Java files without explicit compilation. E.g. <code>java Hello.java</code></p> </li> </ul>"},{"location":"01-compiler/#java-shell-jshell","title":"Java Shell (<code>jshell</code>)","text":"<ul> <li><code>jshell</code> is a REPL (Read\u2013Eval\u2013Print Loop) for Java introduced in Java 9. </li> <li>Start it by running:   <pre><code>jshell\n</code></pre></li> <li>Modes:<ul> <li>Interactive mode for experimentation.</li> <li>Script mode using <code>.jsh</code> files.</li> </ul> </li> <li>Usage notes:<ul> <li>Useful for quick testing, learning, and prototyping without creating full source files.</li> <li>You can declare variables, define methods, and call APIs directly in the REPL.</li> </ul> </li> </ul>"},{"location":"01-compiler/#compiler-functions","title":"Compiler Functions","text":"<ul> <li>Translates source code to machine code/bytecode</li> <li>Checks code for syntax errors<ul> <li>Compilation errors are caught during development, allowing programmers to fix them early.</li> <li>Runtime errors are less desirable because they occur while the program is running, potentially affecting users.</li> <li>The goal is to catch as many errors as possible at compile time, rather than during execution.</li> </ul> </li> <li>Performs type checking</li> <li>Can be either:<ul> <li>Conservative: Reports error if possibility of incorrect statement</li> <li>Permissive: Only reports error if statement is definitely incorrect</li> </ul> </li> </ul>"},{"location":"01-compiler/#compiler-limitations","title":"Compiler Limitations","text":"<ul> <li>Cannot detect all runtime errors during compilation</li> <li>Cannot always determine if code will be executed</li> <li>Cannot always determine variable values at compile time</li> </ul>"},{"location":"01-compiler/#workflow","title":"Workflow","text":"<ol> <li>Create or edit file containing Java program (<code>Hello.java</code>) with an editor (<code>vim</code>).</li> <li>Compile source code using a compiler (<code>javac Hello.java</code>) to produce a bytecode file (<code>.class</code>)</li> <li>Execute the program (<code>java Hello</code>)</li> </ol>"},{"location":"02-type/","title":"Variable and Type Summary","text":""},{"location":"02-type/#data-abstraction-variable","title":"Data Abstraction: Variable","text":"<ul> <li>Variables are named abstractions for accessing values in memory</li> <li>Primitive variables store actual values and are independent</li> <li>Reference variables store memory addresses and can share objects in memory</li> <li>You use the variable name to access the value</li> </ul>"},{"location":"02-type/#types","title":"Types","text":"<ul> <li>Manage program complexity</li> <li>Communicate data type information to readers</li> <li>Allow compiler to check for valid operations</li> <li>Determine how operations behave</li> <li> <p>Operation Examples:</p> <pre><code>String x = \"4\";\nString y = \"5\";\nString result1 = x + y;  // \"45\" (concatenation)\n\nint x = 4;\nint y = 5;\nint result2 = x + y;     // 9 (addition)\n\nint x = 4;\nString y = \"5\";\nString result3 = x + y;  // \"45\" (int converted to String, then concatenated)\n</code></pre> </li> </ul>"},{"location":"02-type/#static-vs-dynamic-typing","title":"Static vs Dynamic Typing","text":"<ul> <li> <p>Dynamic Typing (e.g., Python, JavaScript)</p> <ul> <li>Variables can hold different types</li> <li>Type checking done at runtime</li> <li>Type associated with values</li> <li>Example: <code>x = 1; x = \"hello\"</code> is valid</li> </ul> </li> <li> <p>Static Typing (e.g., Java)</p> <ul> <li>Variables must declare their type at compile time</li> <li>Type checking done at compile time</li> <li>Variable type cannot change after declaration</li> <li>Types are attached to variables to restrict stored value types</li> <li>Example: <code>int x = 1; x = \"hello\";</code> is invalid (compile error)</li> </ul> </li> </ul>"},{"location":"02-type/#strong-vs-weak-typing","title":"Strong vs Weak Typing","text":"<ul> <li>Represents a spectrum of \"strength\" in a language's typing discipline</li> <li>Strong Typing<ul> <li>Enforces strict type rules</li> <li>Ensures type safety at runtime</li> <li>Prevents unsafe implicit type conversions</li> <li>Example: Java prevents automatic conversion from String to int</li> </ul> </li> <li>Weak Typing<ul> <li>More permissive with type rules</li> <li>Allows potentially unsafe implicit type conversions</li> <li>Example: C allows casting between unrelated pointer types</li> </ul> </li> </ul>"},{"location":"02-type/#java-primitive-types","title":"Java Primitive Types","text":"<ul> <li>Boolean: <code>boolean</code> (1 bit)</li> <li>Character: <code>char</code> (16 bits)</li> <li>Integral Types:<ul> <li><code>byte</code> (8 bits)</li> <li><code>short</code> (16 bits)</li> <li><code>int</code> (32 bits)</li> <li><code>long</code> (64 bits)</li> </ul> </li> <li>Floating-Point:<ul> <li><code>float</code> (32 bits)</li> <li><code>double</code> (64 bits)</li> </ul> </li> <li>Bit sizes determine the range of values a type can represent</li> <li>Use suffix <code>L</code> for long literals: <code>long x = 100L;</code></li> <li>Floating-point literals default to <code>double</code>; use suffix <code>f</code> for float: <code>float x = 3.14f;</code></li> </ul>"},{"location":"02-type/#subtyping","title":"Subtyping","text":"<ul> <li>Defines when one type can substitute another: T &lt;: S (T is subtype of S)<ul> <li>Code written for variables of type S can safely use variables of type T</li> <li>S is a supertype of T, T is a subtype of S</li> </ul> </li> <li>Properties:<ul> <li>Reflexive: S &lt;: S (subtype of itself)</li> <li>Transitive: If S &lt;: T and T &lt;: U, then S &lt;: U</li> <li>Anti-symmetric: If S &lt;: T and T &lt;: S, then S = T</li> </ul> </li> </ul>"},{"location":"02-type/#java-primitive-type-hierarchy","title":"Java Primitive Type Hierarchy","text":"<ul> <li>Subtype relationships:<ul> <li><code>byte</code> &lt;: <code>short</code> &lt;: <code>int</code> &lt;: <code>long</code> &lt;: <code>float</code> &lt;: <code>double</code></li> <li><code>char</code> &lt;: <code>int</code></li> </ul> </li> <li>Widening conversions allow assigning value of type T to variable of type S if T &lt;: S</li> <li>Example: <pre><code>double d = 5.0; // assign 5.0 to d (double)\nint i = 5;      // assign 5 to i (int)\nd = i;          // valid: int &lt;: double (widening conversion)\ni = d;          // invalid: double \u226e: int (would require narrowing cast)\n</code></pre></li> </ul>"},{"location":"03-function/","title":"Functions Summary","text":""},{"location":"03-function/#computation-abstraction-functions","title":"Computation Abstraction: Functions","text":"<ul> <li>Functions group instructions and give them a name</li> <li>Allow composition at higher levels of abstraction</li> <li>Basic Java function syntax:   <pre><code>return_type function_name(param_type1 param1, param_type2 param2) {\n  function body\n}\n</code></pre></li> <li>Return type is mandatory (use <code>void</code> if no return value)</li> <li>Java doesn't support returning multiple values</li> <li>If returning multiple values is needed, use a data type that can store multiple values</li> </ul>"},{"location":"03-function/#benefits-of-functions","title":"Benefits of Functions","text":""},{"location":"03-function/#compartmentalization","title":"Compartmentalization","text":"<ul> <li>Isolates computation and effects</li> <li>Limits interactions to parameters and return values</li> <li>Reduces number of variables to track</li> <li>Contains complexity within function body</li> <li>Example   <pre><code>int factorial(int n) {\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n\n// Approximation of e^n using Taylor series\n// e^n \u2248 1^0/0! + n^1/1! + n^2/2! + ...\ndouble e(int n) {\n  int x = 1; // x stands for n^i\n  double res = 0; // total of the e^n\n  for(int i = 0; i &lt; 10; i++) {\n    res += x / factorial(i);\n    x = x * n;\n  }\n  return res;\n}\n// The n in factorial function is different from the n in e function\n</code></pre></li> </ul>"},{"location":"03-function/#implementation-hiding","title":"Implementation Hiding","text":"<ul> <li>Hides how a task is performed</li> <li>Caller only needs to know what function does</li> <li>Reduces information needed between programmers</li> <li>Allows implementation changes without affecting callers</li> <li>Example:   <pre><code>double sinc(double x) {\n  return Math.sin(x) / x;\n} \n// Unnormalized signal processing function\n// sinc function sinc(x) = sin(x)/x\n// Caller only needs to know what sinc does, not the implementation details\n</code></pre></li> </ul>"},{"location":"03-function/#code-reuse","title":"Code Reuse","text":"<ul> <li>Reduces repeated code through parameterization</li> <li>Makes code more succinct and readable</li> <li>Reduces places that need modification when code evolves</li> <li>Decreases chance of introducing bugs</li> <li>Example:   <pre><code>double distance(double x1, double y1, double x2, double y2) {\n  double xCoordinates = Math.pow((x2 - x1), 2);\n  double yCoordinates = Math.pow((y2 - y1), 2);\n  return Math.sqrt(xCoordinates + yCoordinates);\n}\n\nboolean isEquilateral(double x1, double y1, double x2, double y2, double x3, double y3) {\n  return distance(x1, y1, x2, y2) == distance(x1, y1, x3, y3)\n      &amp;&amp; distance(x1, y1, x2, y2) == distance(x2, y2, x3, y3); \n}\n</code></pre></li> </ul>"},{"location":"03-function/#abstraction-barrier","title":"Abstraction Barrier","text":"<ul> <li>Separates code that calls function from code that implements function</li> <li>Divides programmer roles:<ul> <li>Implementer: provides implementation</li> <li>Client: uses the function</li> </ul> </li> <li>Enforces separation of concerns</li> <li>Allows implementation changes without affecting client code</li> <li>Protects implementation details from client</li> <li>The separation allows collaborative programming when people work on the same codebase</li> <li>Example:   <pre><code>public class MathSquare {\n  private int square(int x) {\n    return x * x;\n  } // private function for implementer to hide the logic\n\n  public int useSquare(int x) {\n    return square(x);\n  } // public function for client usage\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    MathSquare sq = new MathSquare();\n    int result = sq.useSquare(5);\n    System.out.println(\"The result is: \" + result);  \n  }\n}\n</code></pre></li> </ul>"},{"location":"03-function/#pure-functions","title":"Pure Functions","text":"<ul> <li>Functions that behave like mathematical functions</li> <li>Given same input, always produce same output</li> <li>Have no side effects (don't modify external state)</li> <li>Example:   <pre><code>int square(int i) {\n  return i * i;\n}\n</code></pre></li> </ul>"},{"location":"03-function/#non-pure-functions","title":"Non-Pure Functions","text":"<ul> <li>May throw exceptions</li> <li>May modify external state</li> <li>May depend on external state</li> <li>May not return a value</li> <li>Example:   <pre><code>void addToQueue(Queue&lt;Integer&gt; queue, int i) {\n  queue.enq(i);  // has side effects on queue\n}\n</code></pre></li> </ul>"},{"location":"03-function/#variable-arguments-varargs","title":"Variable Arguments (Varargs)","text":"<ul> <li>Allows methods to accept variable number of arguments</li> <li>Uses ellipsis (<code>...</code>) in parameter declaration</li> <li>Must be the last parameter in method signature</li> <li>Internally treated as an array</li> <li>Example:   <pre><code>void printAll(String... messages) {\n  for (String msg : messages) {\n    System.out.println(msg);\n  }\n}\n</code></pre></li> <li>Can be called with:   <pre><code>printAll(\"Hello\");                    // one argument\nprintAll(\"Hello\", \"World\");          // two arguments\nprintAll(\"A\", \"B\", \"C\", \"D\");        // multiple arguments\nprintAll();                          // zero arguments\n</code></pre></li> <li>Can also be called with an array:   <pre><code>String[] messages = {\"A\", \"B\", \"C\"};\nprintAll(messages);                   // passing array directly\n</code></pre></li> </ul>"},{"location":"04-encapsulation/","title":"Encapsulation Summary","text":""},{"location":"04-encapsulation/#composite-data-type","title":"Composite Data Type","text":"<ul> <li>Groups primitive types together into new types</li> <li>Gives the group a name for future reference</li> <li>Abstracts away implementation details</li> <li>Examples: complex numbers, 2D points, vectors</li> </ul>"},{"location":"04-encapsulation/#class-and-object","title":"Class and Object","text":"<ul> <li>Class: Bundles composite data type with associated functions</li> <li>Uses class abstraction as a tool to define composite data type and add methods that operate on the data (fields)</li> <li>Components:<ul> <li>Fields (also called states, attributes, or properties)</li> <li>Methods (functions that operate on the fields)</li> </ul> </li> <li>Objects: Instances of a class</li> <li>Example:   <pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre></li> </ul>"},{"location":"04-encapsulation/#encapsulation","title":"Encapsulation","text":"<ul> <li>Keep all the data (fields) and functions (methods) operating on the data (fields) related to a composite data type together within an abstraction barrier</li> </ul>"},{"location":"04-encapsulation/#object-creation-and-access","title":"Object Creation and Access","text":"<ul> <li>Objects created using <code>new</code> keyword</li> <li>Objects as instances of a class:</li> <li>Each object allows the same methods to be called</li> <li>Each object contains the same set of variables of the same types</li> <li>Each object may store different values</li> <li>Access fields and methods using dot <code>.</code> notation</li> <li>Example:   <pre><code>Circle c = new Circle();\nc.r = 10;\nc.getArea();\n</code></pre></li> </ul>"},{"location":"04-encapsulation/#object-oriented-programming-principles","title":"Object-Oriented Programming Principles","text":"<ul> <li>Program consists of interacting objects</li> <li>Objects contain:<ul> <li>Data (fields)</li> <li>Operations (methods AKA functions)</li> </ul> </li> <li>Natural modeling of real-world objects</li> <li>Models:<ul> <li>Nouns as classes/objects</li> <li>Properties/relationships as fields</li> <li>Actions as methods</li> </ul> </li> </ul>"},{"location":"04-encapsulation/#reference-types-in-java","title":"Reference Types in Java","text":"<ul> <li>Classes are reference types</li> <li>Variables store references to objects, not objects themselves</li> <li>Multiple variables can reference same object</li> <li>Example of sharing:   <pre><code>Circle c1 = new Circle();\nCircle c2 = c1;  // c1 and c2 share same object\nc1.r = 10;       // affects both c1 and c2\n</code></pre></li> </ul>"},{"location":"04-encapsulation/#special-reference-value-null","title":"Special Reference Value: null","text":"<ul> <li>Default value for uninitialized reference variables</li> <li>Attempting to use null reference causes NullPointerException</li> <li>Must initialize reference variables before use</li> <li>Example:   <pre><code>Circle c1;           // c1 is null\nc1.r = 10;          // NullPointerException\n</code></pre></li> </ul>"},{"location":"04-encapsulation/#good-design-practices","title":"Good Design Practices","text":"<ul> <li>Keep related data and methods together</li> <li>Hide implementation details</li> <li>Model real-world relationships appropriately</li> <li>Initialize references before use</li> <li>Be careful with shared references</li> </ul>"},{"location":"05-infohiding/","title":"Information Hiding Summary","text":""},{"location":"05-infohiding/#breaking-abstraction-barrier","title":"Breaking Abstraction Barrier","text":"<ul> <li>Direct access to internal fields breaks abstraction</li> <li>Example problem:   <pre><code>Circle c = new Circle();\nc.r = 10;  // directly modifying radius\n</code></pre></li> <li>Makes code dependent on implementation details</li> <li>Changes to implementation can break client code</li> <li>Reduces code maintainability</li> <li>As an implementer, expose as few fields/methods as possible</li> <li>As a client, follow the behavior as stated in the specification such as <code>Java API</code></li> </ul>"},{"location":"05-infohiding/#access-modifiers","title":"Access Modifiers","text":"<ul> <li>Java provides access control through modifiers:<ul> <li><code>private</code>: Only accessible within the class</li> <li><code>public</code>: Accessible from anywhere</li> </ul> </li> <li>Default access (no modifier) exists but not covered; it is package-private</li> <li>Access control enforced by compiler at compile time</li> <li>Different objects of the same class can access each other's private fields and methods within the class</li> <li>Example:   <pre><code>class Circle {\n  private double x;  // hidden from outside\n  private double y;\n  private double r;\n\n  public double getArea() {  // accessible from outside\n    return 3.141592653589793 * r * r;\n  }\n}\n\n// Testing\nCircle c = new Circle();\nc.r = 10; // compilation error\n</code></pre></li> </ul>"},{"location":"05-infohiding/#access-modifier-summary-table","title":"Access Modifier Summary Table","text":"Access From private public Inside class Yes Yes Outside class No Yes"},{"location":"05-infohiding/#constructors","title":"Constructors","text":"<ul> <li>Behavior of a constructor:<ul> <li>Allocate memory for all fields and assign the reference to <code>this</code></li> <li>Invoke the constructor function, passing the keyword <code>this</code> implicitly</li> <li>Once the constructor is done, return the reference pointed to by <code>this</code></li> </ul> </li> <li>Special methods for clients to initialize objects</li> <li>Same name as class</li> <li>No return type</li> <li>Called automatically with <code>new</code></li> <li>Example:   <pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n}\n</code></pre></li> </ul>"},{"location":"05-infohiding/#default-constructor","title":"Default Constructor","text":"<ul> <li>Provided by Java if no constructor is defined</li> <li>Takes no parameters</li> <li>Empty body</li> <li>Example:   <pre><code>Circle() {\n} // no parameters and no code written for the body\n</code></pre></li> <li>Not provided if any constructor is defined</li> </ul>"},{"location":"05-infohiding/#the-this-keyword","title":"The <code>this</code> Keyword","text":"<ul> <li>Reference to current object</li> <li>Used to:<ul> <li>Distinguish between parameters and fields</li> <li>Access object's own members</li> </ul> </li> <li>Example:   <pre><code>this.x = x;  // field x = parameter x\n</code></pre></li> <li>Makes code more explicit and readable</li> <li>Helps avoid naming conflicts</li> </ul>"},{"location":"06-tell-dont-ask/","title":"Tell, Don't Ask Summary","text":""},{"location":"06-tell-dont-ask/#accessors-and-mutators","title":"Accessors and Mutators","text":"<ul> <li>Accessor (getter): Methods to retrieve field values</li> <li>Mutator (setter): Methods to modify field values</li> <li>Example:   <pre><code>class Circle {\n  private double r;\n\n  public double getR() {     // accessor\n    return this.r;\n  }\n\n  public void setR(double r) { // mutator\n    this.r = r;\n  }\n}\n</code></pre></li> </ul>"},{"location":"06-tell-dont-ask/#accessormutator-vs-public-fields","title":"Accessor/Mutator vs Public Fields","text":""},{"location":"06-tell-dont-ask/#advantages-over-public-fields","title":"Advantages over public fields:","text":"<ul> <li>Adds layer of abstraction</li> <li>Can rename fields without affecting clients</li> <li>Can add validation in mutators</li> <li>Can control access to fields</li> <li>Example with validation:   <pre><code>public void setR(double r) {\n  if (r &gt; 0) {\n    this.r = r;\n  }\n}\n</code></pre></li> </ul>"},{"location":"06-tell-dont-ask/#problems-with-accessorsmutators","title":"Problems with Accessors/Mutators","text":"<ul> <li>Can leak implementation details</li> <li>Creates coupling between client and class (cannot change the name of the accessors or mutators)</li> <li>Makes code harder to maintain</li> <li>Example of coupling:   <pre><code>// Client code depends on internal representation\ndouble cX = c.getX();\ndouble cY = c.getY();\ndouble r = c.getR();\nboolean isInCircle = ((x - cX) * (x - cX) + \n                     (y - cY) * (y - cY)) &lt;= r * r;\n</code></pre></li> </ul>"},{"location":"06-tell-dont-ask/#tell-dont-ask-principle","title":"Tell, Don't Ask Principle","text":"<ul> <li>Tell objects what to do</li> <li>Don't ask for internal state</li> <li>Let objects perform their own operations</li> <li>Better example:   <pre><code>// Tell the object what to do\nboolean isInCircle = c.contains(x, y);\n\n// Instead of asking for internal state\ndouble cX = c.getX();\ndouble cY = c.getY();\ndouble r = c.getR();\nboolean isInCircle = ((x - cX) * (x - cX) + (y - cY) * (y - cY)) &lt;= r * r;\n</code></pre></li> </ul>"},{"location":"06-tell-dont-ask/#benefits-of-tell-dont-ask","title":"Benefits of Tell, Don't Ask","text":"<ul> <li>Maintains encapsulation</li> <li>Reduces coupling between classes</li> <li>Makes code more maintainable</li> <li>Keeps related computations together</li> <li>Allows implementation changes without affecting clients</li> </ul>"},{"location":"06-tell-dont-ask/#guidelines","title":"Guidelines","text":"<ul> <li>Tasks involving only class fields should be in that class</li> <li>Avoid getters/setters unless absolutely necessary</li> <li>Think in terms of object responsibilities</li> <li>Focus on object behavior rather than state</li> <li>Design methods around what objects should do</li> </ul>"},{"location":"07-static-field/","title":"Static Field Summary","text":""},{"location":"07-static-field/#class-fields-static-fields","title":"Class Fields (Static Fields)","text":"<ul> <li>Fields associated with class rather than instances</li> <li>Declared using <code>static</code> keyword</li> <li>Shared across all instances of the class</li> <li>Can be accessed without creating class instance</li> <li>Example:   <pre><code>// Universal field: PI\nclass Math {\n  public static final double PI = 3.141592653589793;\n}\n</code></pre></li> </ul>"},{"location":"07-static-field/#common-modifiers-for-class-fields","title":"Common Modifiers for Class Fields","text":"<ul> <li><code>static</code>: Makes field belong to class</li> <li><code>final</code>: Makes field value unchangeable</li> <li><code>public</code>: Makes field accessible outside class</li> <li>Common combination: <code>public static final</code> for defining globally accessible constants.</li> </ul>"},{"location":"07-static-field/#accessing-class-fields","title":"Accessing Class Fields","text":"<ul> <li>Access through class name: <code>Math.PI</code></li> <li>Example:   <pre><code>public double getArea() {\n  return java.lang.Math.PI * this.r * this.r;\n}\n</code></pre></li> <li>Can use import statement to simplify access</li> <li>Example:   <pre><code>import java.lang.Math;\n\n// Now can use Math.PI directly\npublic double Circumference() {\n  return Math.PI * this.r * 2;\n}\n</code></pre></li> </ul>"},{"location":"07-static-field/#instance-fields-vs-class-fields","title":"Instance Fields vs Class Fields","text":"<ul> <li> <p>Instance fields (non-static field):</p> <ul> <li>Belong to specific object instances</li> <li>Each object has its own separate copy of the field</li> <li>Accessed through object reference</li> </ul> </li> <li> <p>Class fields (static field):</p> <ul> <li>Belong to class itself</li> <li>Single copy shared by all instances</li> <li>Accessed through class name</li> <li>Loaded into memory when class is loaded by JVM, even if no objects are created</li> </ul> </li> </ul>"},{"location":"07-static-field/#best-practices","title":"Best Practices","text":"<ul> <li>Use class fields for:<ul> <li>Constants</li> <li>Values shared across all instances</li> <li>Configuration parameters</li> <li>Pre-computed values</li> </ul> </li> <li>Make class fields final when possible</li> <li>Use meaningful names for constants</li> <li>Consider using existing constants (e.g., Math.PI)</li> </ul>"},{"location":"08-static-method/","title":"Static Method Summary","text":""},{"location":"08-static-method/#class-methods-static-methods","title":"Class Methods (Static Methods)","text":"<ul> <li>Methods associated with class rather than instances</li> <li>Declared using <code>static</code> keyword</li> <li>Can be called without creating class instance</li> <li>Cannot access instance fields/methods directly</li> <li>Cannot use <code>this</code> keyword</li> <li>Example:   <pre><code>class Math {\n  public static double sqrt(double x) {\n    // compute square root\n  }\n}\n</code></pre></li> </ul>"},{"location":"08-static-method/#static-vs-non-static-methods","title":"Static vs Non-Static Methods","text":"<ul> <li> <p>Static methods:</p> <ul> <li>Belong to class</li> <li>Can only access static members</li> <li>Called through class name</li> <li>No access to <code>this</code> <ul> <li>Static method exists without instantiating the class </li> <li><code>this</code> refers to a specific object instance, which static methods do not have </li> </ul> </li> </ul> </li> <li> <p>Non-static methods:</p> <ul> <li>Belong to instances</li> <li>Can access all members</li> <li>Called through instance</li> <li>Has access to <code>this</code></li> </ul> </li> </ul>"},{"location":"08-static-method/#non-static-from-static-context","title":"Non-Static from Static Context","text":"<ul> <li>Static methods cannot access:<ul> <li>Instance fields</li> <li>Instance methods</li> <li><code>this</code> reference</li> </ul> </li> <li>Example of invalid code:   <pre><code>class A {\n  private int x;\n  public static void foo() {\n    this.x = 1;  // Error: cannot use `this`\n    x = 1;       // Error: cannot access instance field\n  }\n}\n</code></pre></li> </ul>"},{"location":"08-static-method/#the-main-method","title":"The <code>main</code> Method","text":"<ul> <li>Special static method as program entry point</li> <li>Required signature:   <pre><code>public static void main(String[] args)\n</code></pre></li> <li>Characteristics:<ul> <li>Must be <code>public</code></li> <li>Must be <code>static</code></li> <li>Must return <code>void</code></li> <li>Must take String array parameter</li> <li>Name must be <code>main</code></li> </ul> </li> </ul>"},{"location":"08-static-method/#command-line-arguments","title":"Command Line Arguments","text":"<ul> <li>Passed to <code>String[]</code> array of main method</li> <li><code>args</code> parameter stores command line arguments</li> <li>Example:   <pre><code>public static void main(String[] args) {\n  // args[0] is first argument\n  // args[1] is second argument\n  // etc.\n}\n</code></pre></li> </ul>"},{"location":"08-static-method/#factory-methods","title":"Factory Methods","text":"<ul> <li>Static methods that create objects</li> <li>Benefits:</li> <li>When object creation needs to be controlled </li> <li>Better naming than constructors</li> <li>Can return cached instances</li> <li> <p>Can return different subtypes </p> </li> <li> <p>Example:   <pre><code>public class Color {\n  private final int red;\n  private final int green;\n  private final int blue;\n\n  private Color(int r, int g, int b) {\n    red = r;\n    green = g;\n    blue = b;\n  }\n\n  public static Color of(int r, int g, int b) {\n    // Validation and caching logic here\n    return new Color(r, g, b);\n  }\n\n}\n</code></pre></p> </li> </ul>"},{"location":"08-static-method/#best-practices","title":"Best Practices","text":"<ul> <li>Use static methods for:<ul> <li>Utility functions that perform general operations and don't depend on instance state (data)<ul> <li>Example: <pre><code>class MathUtils {\n  public static int square(int x) {\n    return x * x;\n  }\n}\n</code></pre></li> </ul> </li> <li>Accessing or managing static fields<ul> <li>Example: <pre><code>class Circle {\n  private final int id;\n  private static int lastId = 0;\n\n  public Circle() {\n    this.id = Circle.lastId;\n    Circle.lastId += 1;\n  }\n\n  // Access static field\n  public static int getNumOfCircles() {\n    return Circle.lastId;\n  }\n}\n</code></pre></li> </ul> </li> </ul> </li> <li>Keep static methods independent of instance state</li> <li>Consider making utility classes final</li> <li>Document command line arguments clearly</li> </ul>"},{"location":"09-composition/","title":"Composition Summary","text":""},{"location":"09-composition/#composition-concept","title":"Composition Concept","text":"<ul> <li>Building complex classes using simpler classes</li> <li>Models \"HAS-A\" relationship between classes</li> <li>Example:   <pre><code>class Circle {\n  private Point c;   // Circle HAS-A Point\n  private double r;\n}\n</code></pre></li> </ul>"},{"location":"09-composition/#benefits-of-composition","title":"Benefits of Composition","text":"<ul> <li>Builds layers of abstraction</li> <li>Encapsulates implementation details</li> <li>Makes code more modular</li> <li>Allows reuse of existing classes</li> <li>Simplifies complex class implementations</li> </ul>"},{"location":"09-composition/#example-of-composition","title":"Example of Composition","text":"<pre><code>// Building up from Point to Circle to Cylinder\nclass Point {\n  private double x;\n  private double y;\n}\n\nclass Circle {\n  private Point center; // Circle HAS-A Point\n  private double radius;\n}\n\nclass Cylinder {\n  private Circle base; // Cylinder HAS-A Circle\n  private double height;\n}\n</code></pre>"},{"location":"09-composition/#reference-sharing-issues-aliasing","title":"Reference Sharing Issues (Aliasing)","text":"<ul> <li>Objects can share references to components</li> <li>Changes to shared components affect all objects</li> <li>Example of problematic sharing:   <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\np.moveTo(1, 1);  // affects both c1 and c2\n</code></pre></li> </ul>"},{"location":"09-composition/#solutions-to-reference-sharing","title":"Solutions to Reference Sharing","text":"<ol> <li> <p>Avoid Sharing References    <pre><code>Point p1 = new Point(0, 0);\nCircle c1 = new Circle(p1, 1);\nPoint p2 = new Point(0, 0);\nCircle c2 = new Circle(p2, 4);\n</code></pre></p> </li> <li> <p>Create Defensive Copies    <pre><code>// Defensive copy ensures that external changes to `c` do not affect Circle\nclass Circle {\n  public Circle(Point c, double r) {\n    this.c = new Point(c.getX(), c.getY());\n    this.r = r;\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"09-composition/#trade-offs","title":"Trade-offs","text":"<ul> <li>Avoiding sharing:<ul> <li>Pros: Prevents unintended modifications</li> <li>Cons: Uses more memory, less efficient</li> </ul> </li> <li>Sharing references:<ul> <li>Pros: Memory efficient</li> <li>Cons: Can lead to bugs, harder to maintain</li> </ul> </li> </ul>"},{"location":"09-composition/#best-practices","title":"Best Practices","text":"<ul> <li>Consider carefully whether to share references</li> <li>Document sharing behavior clearly</li> <li>Use defensive copying when appropriate</li> <li>Consider making objects immutable</li> <li>Design classes to prevent accidental sharing</li> </ul>"},{"location":"10-heap-stack/","title":"Heap and Stack Summary","text":""},{"location":"10-heap-stack/#jvm-memory-regions","title":"JVM Memory Regions","text":"<ul> <li>Method area: Stores method code</li> <li>Metaspace: Stores class metadata</li> <li>Heap: Stores dynamically allocated objects</li> <li>Stack: Stores local variables and call frames</li> </ul>"},{"location":"10-heap-stack/#stack","title":"Stack","text":"<ul> <li>Holds local variables (not instance or class fields)</li> <li>Organized into call frames (one per method call)</li> <li>Follows a Last-In-First-Out (LIFO) order</li> <li>Each call frame contains:<ul> <li>Local variables</li> <li>Method parameters</li> <li>Reference to <code>this</code> (for non-static methods)</li> </ul> </li> <li>A new frame is created when a method is called and removed when the method finishes</li> </ul>"},{"location":"10-heap-stack/#heap","title":"Heap","text":"<ul> <li>Stores objects created with <code>new</code></li> <li>Objects can be shared between methods and variables</li> <li>Each object contains:<ul> <li>Class name</li> <li>Instance fields and their values</li> <li>Captured variables (for nested classes)</li> </ul> </li> <li>No LIFO restriction; objects can outlive the methods that created them</li> </ul>"},{"location":"10-heap-stack/#constructor-example","title":"Constructor Example","text":"<pre><code>Point p;                  // Stack: p (uninitialized)\np = new Point(1, 2);      // Heap: new Point object\n                          // Stack: p now references the Point\n                          // Constructor call creates a new call frame\n</code></pre> Declare Point variable on stack (null placeholder)Allocate Point object on heapInvoke Constructor (new Point(1, 2))Constructor completes (pop frame)Assign object reference to p <ul> <li>The symbol \u2205 indicates an uninitialized variable</li> <li>Each constructor call creates a new stack frame containing:<ul> <li>The <code>this</code> reference</li> <li>Constructor parameters</li> <li>Local variables</li> </ul> </li> </ul>"},{"location":"10-heap-stack/#method-call-example","title":"Method Call Example","text":"<pre><code>class Point {\n  private double x;\n  private double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public void move(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPoint p1 = new Point(0, 0);\nPoint p2 = new Point(1, 1);\ndouble x = 5;\ndouble y = 5;\np1.move(x, y);\n</code></pre> After Lines 1-2: p1 and p2 objects createdAfter Lines 3-4: x and y primitives assignedLine 5: move method invokedMethod completes, frame poped, p1 updated <ul> <li>Each method call creates a new stack frame</li> <li>The frame is destroyed when the method returns</li> <li>Method parameters are copied into the new frame</li> </ul>"},{"location":"10-heap-stack/#best-practices","title":"Best Practices","text":"<ul> <li>Understand the lifetime of objects and variables</li> <li>Be aware of when objects are shared or referenced</li> <li>Know the difference between stack and heap allocation</li> <li>Clean up references when no longer needed</li> <li>Be mindful of memory usage patterns</li> </ul>"},{"location":"11-inheritance/","title":"Inheritance Summary","text":""},{"location":"11-inheritance/#inheritance-concept","title":"Inheritance Concept","text":"<ul> <li>Mechanism to extend existing code</li> <li>Models \"IS-A\" relationship between classes</li> <li>Uses <code>extends</code> keyword in Java</li> <li>Example:   <pre><code>class ColoredCircle extends Circle {\n  private Color color;\n}\n</code></pre></li> </ul>"},{"location":"11-inheritance/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Subclass inherits:<ul> <li>Public fields from parent</li> <li>Public methods from parent</li> </ul> </li> <li>Private members remain inaccessible</li> <li><code>super</code> keyword accesses parent members</li> <li><code>super</code> keyword must be first statement in constructor</li> <li>Example:   <pre><code>class ColoredCircle extends Circle {\n  public ColoredCircle(Point center, double radius, Color color) {\n    super(center, radius);  // call parent constructor to initialise its centre and radius\n    this.color = color;\n  }\n}\n</code></pre></li> </ul>"},{"location":"11-inheritance/#when-to-use-inheritance","title":"When to Use Inheritance","text":"<ul> <li>Use when subclass IS-A superclass</li> <li>Subclass should be substitutable for superclass</li> <li>Example of proper use:   <pre><code>// Square IS-A Shape\nclass Square extends Shape { }\n</code></pre></li> <li>Example of improper use:   <pre><code>// Circle is not a Point\nclass Circle extends Point { }\n</code></pre></li> </ul>"},{"location":"11-inheritance/#composition-vs-inheritance","title":"Composition vs Inheritance","text":"<ul> <li>Composition: HAS-A relationship   <pre><code>class Car {\n  private Engine engine;  // Car HAS-A Engine\n}\n</code></pre></li> <li>Inheritance: IS-A relationship   <pre><code>class Car extends Vehicle {  // Car IS-A Vehicle\n}\n</code></pre></li> </ul>"},{"location":"11-inheritance/#type-checking","title":"Type Checking","text":"<ul> <li>Superclass is not guaranteed to have properties or behaviors of subclass</li> <li>Invalid downcasting to assign a superclass object to a subclass reference will cause compile-time error</li> <li>Example of proper use:   <pre><code>Circle c = new ColoredCircle(p, 0, blue); // OK\n</code></pre></li> <li>Example of improper use:   <pre><code>ColoredCircle c  = new Circle(p, 0); // error\n</code></pre></li> </ul>"},{"location":"11-inheritance/#run-time-type","title":"Run-Time Type","text":"<ul> <li>Compile-time type: Declared type of variable</li> <li>Run-time type: Actual type of object</li> <li>Example:   <pre><code>Shape s = new Circle(p, 1.0); \n// Compile-time type: Shape\n// Run-time type: Circle\n</code></pre></li> </ul>"},{"location":"11-inheritance/#compile-time-type","title":"Compile-Time Type","text":"<ul> <li>Java does not use the information from run-time type</li> <li>Java will only use compile-time type information for type checking</li> <li>Java compiler checks methods based on compile-time type, not run-time type.</li> <li>Example:   <pre><code>class T {\n  public int foo() {\n    return 0;\n  }\n}\nclass S1 extends T {\n  public int bar() {\n    return 1;\n  }\n}\nclass S2 extends T {\n  public int baz() {\n    return 2;\n  }\n}\n</code></pre> <pre><code>T x = new S1();\nx = new S2();  // re-assignment\n// Re-assignment is valid as S1 &lt;: T and S2 &lt;: T based on compile-time type \n</code></pre> <pre><code>T x = new S1();\nx.bar(); // error\n// Based on compile-time type, Type T has no method bar()\n// Even if run-time type to have the method bar(), it is still irrelevant during compile-time checking\n</code></pre></li> </ul>"},{"location":"11-inheritance/#nominal-subtyping","title":"Nominal Subtyping","text":"<ul> <li>Java subtyping relationship is known as nominal subtyping</li> <li>Subtyping relationship must be explicitly declared</li> <li><code>extends</code> keyword to declare subtyping relationship</li> <li>Java prevents a cyclic subtyping</li> <li>Example:   <pre><code>class A extends B {\n}\n\nclass B extends A {\n} // Cyclic inheritance error\n</code></pre></li> </ul>"},{"location":"11-inheritance/#best-practices","title":"Best Practices","text":"<ul> <li>Use inheritance sparingly</li> <li>Prefer composition over inheritance</li> <li>Ensure IS-A relationship exists</li> <li>Document inheritance relationships</li> <li>Keep inheritance hierarchies shallow</li> <li>Consider making classes final if not meant for inheritance</li> </ul>"},{"location":"12-overriding/","title":"Method Overriding Summary","text":""},{"location":"12-overriding/#object-class","title":"Object Class","text":"<ul> <li>Every class implicitly inherits from <code>Object</code></li> <li><code>Object</code> provides common methods:<ul> <li><code>equals(Object obj)</code>: Check equality</li> <li><code>toString()</code>: String representation</li> <li><code>hashCode()</code>: Hash value</li> <li>Others like <code>clone()</code>, <code>finalize()</code></li> <li>Specific reference: <code>Object::equals(Object)</code><ul> <li>The method is defined in class <code>Object</code></li> <li>The method takes one <code>Object</code> parameter</li> </ul> </li> </ul> </li> </ul>"},{"location":"12-overriding/#method-summary","title":"Method Summary","text":"<ul> <li> <p>Method Signature</p> <ul> <li>Includes the name of the method and the type of parameters</li> <li>The information captured are:<ul> <li>Method name</li> <li>Number of parameters</li> <li>Types of parameters</li> <li>Order of parameters</li> <li>Class name (Optional)</li> </ul> </li> <li>Does NOT include:<ul> <li>Return type</li> <li>Parameter names</li> <li>Access modifiers</li> </ul> </li> </ul> </li> <li> <p>Method Descriptor</p> <ul> <li>Includes everything in the method signature + return type</li> </ul> </li> <li> <p>Class names are included for mentioning a specific implementation</p> </li> <li>Exclude the class names to talk about the method regardless of where it is implemented </li> <li>Omit the parameters to talk about all the methods with the given name (C::foo)</li> </ul> Summary Type Without Class Name With Class Name Signature <code>foo(B1, B2)</code> <code>C::foo(B1, B2)</code> Descriptor <code>A foo(B1, B2)</code> <code>A C::foo(B1, B2)</code>"},{"location":"12-overriding/#the-tostring-method","title":"The <code>toString</code> Method","text":"<ul> <li>This method is invoked implicitly during string concatenation and inside <code>System.out.println(..)</code></li> <li>Assignment to a String variable does not invoke this method implicitly</li> <li>Convert a reference object to a <code>String</code> object</li> <li>Override this method in other classes to design customised <code>toString()</code> method</li> <li>Example:   <pre><code>class Person {\n  public String toString() {\n    return \"Dylan\";\n  }\n}\n</code></pre> <pre><code>Person p = new Person();\nString message = \"Name: \" + p; // Implicitly call toString()\n</code></pre> <pre><code>Person p = new Person();\nSystem.out.println(p); // Implicitly call toString()\n</code></pre> <pre><code>Person p = new Person();\nString p2 = p; // Error: incompatible types\n               // toString() is not invoked\n               // Must call p.toString() explicitly\n</code></pre></li> </ul>"},{"location":"12-overriding/#method-overriding","title":"Method Overriding","text":"<ul> <li>Subclass provides new implementation of parent's method</li> <li>Must have same method descriptor as parent</li> <li>Enables polymorphic behavior</li> <li>Example:   <pre><code>class Circle {\n  @Override\n  public String toString() {\n    return \"Circle with radius \" + this.r;\n  }\n}\n</code></pre></li> </ul>"},{"location":"12-overriding/#rules-for-overriding","title":"Rules for Overriding","text":"<ul> <li>Method must have:<ul> <li>Same name</li> <li>Same parameters (number, type, order)</li> <li>Same return type (or covariant for different return type)</li> <li>Same or less restrictive access</li> </ul> </li> <li>Cannot override:<ul> <li><code>final</code> methods</li> <li><code>static</code> methods</li> <li><code>private</code> methods</li> </ul> </li> </ul>"},{"location":"12-overriding/#override-annotation","title":"@Override Annotation","text":"<ul> <li>Annotation is a hint to the compiler</li> <li>Indicates method is meant to override</li> <li>Helps catch errors at compile time</li> <li>Best practice to always use it</li> <li>Example:   <pre><code>@Override  // Compiler checks if parent has this method\npublic boolean equals(Object obj) {\n  // implementation\n}\n</code></pre></li> </ul>"},{"location":"12-overriding/#using-super-with-overridden-methods","title":"Using <code>super</code> with Overridden Methods","text":"<ul> <li>Access parent class's version using <code>super</code></li> <li>Useful when extending behavior</li> <li>Example:   <pre><code>@Override\npublic String toString() {\n  return super.toString() + \" (custom info)\"; \n}\n</code></pre></li> </ul>"},{"location":"12-overriding/#common-methods-to-override","title":"Common Methods to Override","text":"<ul> <li><code>toString()</code>: String representation</li> <li><code>equals(Object)</code>: Object equality</li> <li><code>hashCode()</code>: Hash code for hash-based collections</li> <li>Example:   <pre><code>@Override\npublic boolean equals(Object obj) {\n  if (obj instanceof Circle) {\n    Circle other = (Circle) obj;\n    return this.radius == other.radius;\n  }\n  return false;\n}\n</code></pre></li> </ul>"},{"location":"12-overriding/#best-practices","title":"Best Practices","text":"<ul> <li>Always use @Override annotation</li> <li>Override toString() for debugging</li> <li>Override equals() and hashCode() together</li> <li>Keep overridden methods consistent with parent class's contract</li> <li>Document overridden behavior</li> </ul>"},{"location":"13-overloading/","title":"Method Overloading Summary","text":""},{"location":"13-overloading/#method-overloading-concept","title":"Method Overloading Concept","text":"<ul> <li>Multiple methods with same name but different parameters </li> <li>Based on method signature differences</li> <li>Example:   <pre><code>class Calculator {\n  public int add(int x, int y) { return x + y; }\n  public int add(int x, int y, int z) { return x + y + z; }\n  public double add(double x, double y) { return x + y; }\n}\n</code></pre></li> </ul>"},{"location":"13-overloading/#valid-vs-invalid-overloading","title":"Valid vs Invalid Overloading","text":"<ul> <li>Valid overloading:   <pre><code>void process(int x, double y) { }\nvoid process(double x, int y) { }    // Different parameter order\nvoid process (double x, double y) { } // Different parameter types\nvoid process(int x, int y, int z) { } // Different number of parameters\n</code></pre></li> <li>Invalid overloading:   <pre><code>int process(int x, int y) { }\ndouble process(int x, int y) { }     // Only return type differs\nvoid process(int a, int b) { }       // Only parameter names differ\n</code></pre></li> </ul>"},{"location":"13-overloading/#constructor-overloading","title":"Constructor Overloading","text":"<ul> <li>Constructors can also be overloaded</li> <li>Multiple constructors with different parameters provide flexibility for object initialization</li> <li>Example:   <pre><code>class Circle {\n  private Point center;\n  private double radius; \n\n  public Circle(Point center, double radius) { \n    this.center = center;\n    this.radius = radius;\n  }\n\n  public Circle() {  // Default constructor\n    this(new Point(0, 0), 1.0);  // Calls other constructor\n  }\n\n  public Circle(double radius) {  // Single parameter constructor\n    this(new Point(0, 0), radius);\n  }\n}\n</code></pre></li> </ul>"},{"location":"13-overloading/#static-method-overloading","title":"Static Method Overloading","text":"<ul> <li>Static methods can be overloaded</li> <li>Same rules as instance methods</li> <li>Example:   <pre><code>class MathUtils {\n  public static int max(int x, int y) { }\n  public static double max(double x, double y) { }\n  public static int max(int x, int y, int z) { }\n}\n</code></pre></li> </ul>"},{"location":"13-overloading/#best-practices","title":"Best Practices","text":"<ul> <li>Use meaningful parameter variations</li> <li>Keep overloaded methods consistent</li> <li>Don't overload with similar parameter types</li> <li>Consider using different method names if behavior differs significantly</li> <li>Document differences between overloaded methods</li> </ul>"},{"location":"14-polymorphism/","title":"Polymorphism Summary","text":""},{"location":"14-polymorphism/#polymorphism-concept","title":"Polymorphism Concept","text":"<ul> <li>Ability of object reference variables to take multiple forms</li> <li>Method behavior depends on object's runtime type</li> <li>Enables code reuse and flexibility</li> <li>Example:   <pre><code>Animal i; // i is Animal\n\ni = new Dog(); // i takes Dog form\ni.speak(); // prints: Dog barks\n\ni = new Cat(); // i can also take Cat form\ni.speak(); // prints: Cat meows\n</code></pre></li> </ul>"},{"location":"14-polymorphism/#the-equals-method","title":"The <code>equals</code> Method","text":"<ul> <li>Object::equals(Object) compares if two object references refer to the same object. </li> <li>The reference is the memory address of objects</li> <li>Properties:<ul> <li>Reflexive: <code>x.equals(x)</code> must return <code>true</code></li> <li>Symmetric: <code>x.equals(x)</code> is <code>true</code> and <code>y.equals</code> must be <code>true</code></li> <li>Transitive: <code>x.equals(y)</code> and <code>y.equals(z)</code> are true, then <code>x.equals(z)</code> must be <code>true</code></li> <li>Non-null: <code>x.equals(null)</code> must return <code>false</code></li> <li>Usage: <code>obj.equals(arg)</code> and <code>obj</code> must not be <code>null</code></li> </ul> </li> <li><code>equals</code> method example:   <pre><code>Circle c0 = new Circle(new Point(0, 0), 10);\nCircle c1 = new Circle(new Point(0, 0), 10);\nCircle c2 = c1;\n// c2.equals(c1) returns true (same object reference)\n// c0.equals(c1) returns false (different objects in memory)\n\n// Even though c0 and c1 are semantically identical,\n// they are different objects with different memory addresses\n</code></pre></li> </ul>"},{"location":"14-polymorphism/#overriding-equals-for-semantic-equality","title":"Overriding equals for Semantic Equality","text":"<ul> <li>To compare objects based on their content rather than memory address, override the <code>equals</code> method:   <pre><code>@Override\npublic boolean equals(Object obj) {\n  if (this == obj) return true;\n  if (obj instanceof Circle) {\n    Circle circle = (Circle) obj;\n    return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n  }\n  return false;\n}\n// Must take Object parameter\n// Use instanceof or getClass() to check runtime type before casting\n// Explicit downcast needed to access subclass-specific fields\n// A class can access private members of any object of the same class\n// Override must have the same method descriptor as the parent class\n</code></pre></li> </ul>"},{"location":"14-polymorphism/#dynamic-binding","title":"Dynamic Binding","text":"<ul> <li>Method calls resolved at runtime</li> <li>Based on actual object type, not variable type</li> <li>Also called late binding</li> <li>Example:   <pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// At compile time, curr is known as Object type\n// At runtime, based on curr's actual type:\n// - If curr is Circle, invoke Circle.equals(Object)\n// - If curr is Point, invoke Point.equals(Object)  \n// - If curr is String, invoke String.equals(Object)\n</code></pre></li> </ul>"},{"location":"14-polymorphism/#type-casting","title":"Type Casting","text":"<ul> <li>Converting between supertype and subtype</li> <li>Widening conversion (subtype to supertype):<ul> <li>Automatic</li> <li>Always safe   <pre><code>Circle c = new Circle(new Point(0, 0), 1.0);\nShape s = c;  // Widening conversion - no cast needed\nObject obj = c;  // Also widening - completely safe\n</code></pre></li> </ul> </li> <li>Narrowing conversion (supertype to subtype):<ul> <li>Requires explicit cast</li> <li>May cause runtime errors   <pre><code>Shape s = new Circle(new Point(0, 0), 1.0);\nCircle c = (Circle) s;  // Narrowing conversion - explicit cast required\n\n// Dangerous without checking:\nShape s2 = new Rectangle(1, 2);\nCircle c2 = (Circle) s2;  // ClassCastException at runtime!\n</code></pre></li> </ul> </li> </ul>"},{"location":"14-polymorphism/#instanceof-operator","title":"instanceof Operator","text":"<ul> <li>Checks object's runtime type</li> <li>Used before casting to prevent errors</li> <li>Example:   <pre><code>public void processShape(Shape shape) {\n    if (shape instanceof Circle) {\n        Circle c = (Circle) shape;  // Safe cast\n        System.out.println(\"Circle with radius: \" + c.getRadius());\n    } else if (shape instanceof Rectangle) {\n        Rectangle r = (Rectangle) shape;  // Safe cast\n        System.out.println(\"Rectangle: \" + r.getWidth() + \"x\" + r.getHeight());\n    }\n}\n</code></pre></li> </ul>"},{"location":"14-polymorphism/#benefits-of-polymorphism","title":"Benefits of Polymorphism","text":"<ul> <li>Write more general code</li> <li>Code works with future subclasses</li> <li>Reduces code duplication</li> <li>Example:   <pre><code>// Works with any Shape subclass\ndouble totalArea(Shape[] shapes) {\n  double total = 0;\n  for (Shape s : shapes) {\n    total += s.getArea();  // polymorphic call\n  }\n  return total;\n}\n</code></pre></li> </ul>"},{"location":"14-polymorphism/#best-practices","title":"Best Practices","text":"<ul> <li>Design for polymorphism when inheritance is used</li> <li>Use most general type in declarations</li> <li>Cast only when necessary</li> <li>Always check with instanceof before casting</li> <li>Document expected behavior of polymorphic methods</li> </ul>"},{"location":"15-dynamic-binding/","title":"Dynamic Binding Summary","text":""},{"location":"15-dynamic-binding/#method-invocation-process","title":"Method Invocation Process","text":"<ul> <li>For Java to determine the most appropriate method to invoke </li> <li>Two-step process:<ol> <li>Compile-time: Determine method descriptor</li> <li>Runtime: Find and execute actual method</li> </ol> </li> </ul>"},{"location":"15-dynamic-binding/#compile-time-step","title":"Compile-Time Step","text":"<ul> <li>Uses compile-time type of target</li> <li>Searches for all accessible methods in target's class and supertypes</li> <li>Checks for compatible methods with given arguments</li> <li>Selects the most specific compatible method</li> <li>Stores the method's descriptor in the generated bytecode</li> <li>Example:   <pre><code>Shape s = new Circle();  // compile-time type: Shape, runtime type: Circle\ns.getArea();            // Compiler looks for getArea() in Shape hierarchy\n</code></pre></li> </ul>"},{"location":"15-dynamic-binding/#method-specificity","title":"Method Specificity","text":"<ul> <li>Specificity between Overloaded methods</li> <li>Method M is more specific than N if:<ul> <li>All arguments that can be passed to M can also be passed to N</li> <li>The reverse is not necessarily true</li> </ul> </li> <li>Example:   <pre><code>class Example {\n    void draw(Circle c) { }      // More specific\n    void draw(Shape s) { }       // Less specific\n\n    public static void main(String[] args) {\n        Example e = new Example();\n        Circle c = new Circle();\n        e.draw(c);  // Calls draw(Circle) - more specific method\n    }\n}\n</code></pre></li> <li>If multiple methods are equally specific, the compiler generates a compilation error</li> <li>Example:   <pre><code>class Ambiguous {\n    void method(String s, Object o) { }\n    void method(Object o, String s) { }\n\n    // method(new String(), new String()); // Compilation error - ambiguous\n}\n</code></pre></li> </ul>"},{"location":"15-dynamic-binding/#runtime-step","title":"Runtime Step","text":"<ul> <li>Uses runtime type of target </li> <li>Searches for method starting from runtime type</li> <li>Moves up class hierarchy if not found</li> <li>Executes the first method that exactly matches the method descriptor stored at compile time</li> <li>Example:   <pre><code>class Animal {\n    void makeSound() { System.out.println(\"Animal sound\"); }\n}\n\nclass Dog extends Animal {\n    @Override\n    void makeSound() { System.out.println(\"Woof!\"); }\n}\n\nclass Puppy extends Dog {\n    // No makeSound() override\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Puppy();  // Compile-time: Animal, Runtime: Puppy\n        a.makeSound();           // Output: \"Woof!\" (from Dog class)\n    }\n}\n</code></pre></li> </ul>"},{"location":"15-dynamic-binding/#method-search-order","title":"Method Search Order","text":"<ul> <li> <p>The first matching method in Overridden methods</p> <pre><code>1. Check runtime type class\n2. If not found, check parent class\n3. Continue up to Object class\n4. Use first matching method found\n</code></pre> </li> <li> <p>Example:   <pre><code>class A {\n    void foo() { System.out.println(\"A.foo()\"); }\n}\n\nclass B extends A {\n    @Override\n    void foo() { System.out.println(\"B.foo()\"); }\n}\n\nclass C extends B {\n    // No foo() override - will use B's implementation\n}\n\nclass D extends C {\n    @Override\n    void foo() { System.out.println(\"D.foo()\"); }\n}\n\n// Usage\nA obj1 = new C();  \nobj1.foo(); // Calls B.foo() - C doesn't override, so uses parent B\nA obj2 = new D();  \nobj2.foo(); // Calls D.foo() - D has its own implementation\n</code></pre></p> </li> </ul>"},{"location":"15-dynamic-binding/#class-methods-static","title":"Class Methods (Static)","text":"<ul> <li>No dynamic binding</li> <li>Resolved at compile time</li> <li>Based on compile-time type only</li> <li>Example:   <pre><code>Shape s = new Circle();\ns.staticMethod();  // calls Shape's static method regardless of runtime type\n</code></pre></li> </ul>"},{"location":"15-dynamic-binding/#best-practices","title":"Best Practices","text":"<ul> <li>Understand compile-time vs runtime types</li> <li>Be aware of method resolution rules</li> <li>Document overridden method behavior</li> <li>Use @Override to clarify intentions</li> <li>Consider making methods final if overriding not intended</li> </ul>"},{"location":"16-lsp/","title":"Liskov Substitution Principle Summary","text":""},{"location":"16-lsp/#lsp-definition","title":"LSP Definition","text":"<ul> <li>Programmer's responsibility to follow the LSP</li> <li>Subtype must be completely substitutable for its supertype</li> <li>A subclass should not break the expectations set by the superclass.</li> <li>Formal Definition: Let \u03c6(x) be a property provable about objects x of type T. Then \u03c6(y) should be true for objects y of type S where S &lt;: T</li> <li>A subclass should pass all test cases of its superclass</li> <li>Example:   <pre><code>// Superclass Restaurant\npublic class Restaurant {\n  public static final int OPENING_HOUR = 1200;\n  public static final int CLOSING_HOUR = 2200;\n\n  public boolean canMakeReservation(int time) {\n    if (time &lt;= CLOSING_HOUR &amp;&amp; time &gt;= OPENING_HOUR) {\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre> <pre><code>// Subclass LunchRestaurant\npublic class LunchRestaurant extends Restaurant {\n  private final int peakHourStart = 1200;\n  private final int peakHourEnd = 1400;\n\n  @Override\n  public boolean canMakeReservation(int time) {\n    if (time &lt;= peakHourEnd &amp;&amp; time &gt;= peakHourStart) {\n      return false;\n    } else if (time &lt;= CLOSING_HOUR &amp;&amp; time &gt;= OPENING_HOUR) {\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre> <pre><code>// Subclass LunchRestaurant\npublic class DigitalReadyRestaurant extends Restaurant {\n\n  @Override\n  public boolean canMakeReservation(int time) {\n    return true;\n  }\n}\n</code></pre> <pre><code>Restaurant r = new LunchRestaurant();\nr.canMakeReservation(1200) == true; // Is false, therefore test fails\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n// LunchRestaurant violates LSP\n\nRestaurant r = new DigitalReadyRestaurant();\nr.canMakeReservation(1200) == true; // Is true, therefore test passes\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n// DigitalReadyRestaurant is substitutable for Restaurant\n</code></pre></li> </ul>"},{"location":"16-lsp/#preventing-inheritance","title":"Preventing Inheritance","text":"<ul> <li>Use <code>final</code> keyword to prevent inheritance</li> <li>Example: <pre><code>final class String {  // Cannot be inherited\n  // implementation\n}\n</code></pre></li> </ul>"},{"location":"16-lsp/#preventing-method-overriding","title":"Preventing Method Overriding","text":"<ul> <li>Use <code>final</code> keyword on methods</li> <li>Prevents subclasses from changing behavior</li> <li>Example: <pre><code>class Circle {\n  final double getArea() {  // Cannot be overridden\n    return Math.PI * r * r;\n  }\n}\n</code></pre></li> </ul>"},{"location":"16-lsp/#preventing-field-re-assignment","title":"Preventing Field Re-assignment","text":"<ul> <li>Use <code>final</code> keyword on methods</li> <li>Prevents re-assignment to the field</li> <li>Example: <pre><code>class Queue {\n  final static int id = 1;\n}\n</code></pre></li> </ul>"},{"location":"16-lsp/#best-practices","title":"Best Practices","text":"<ul> <li>Design inheritance hierarchies carefully</li> <li>Document expected behavior and constraints</li> <li>Use <code>final</code> when inheritance not intended</li> <li>Test subclasses against superclass contracts</li> <li>Consider composition over inheritance</li> <li>Make classes immutable when possible</li> <li>Write clear specifications for methods</li> </ul>"},{"location":"17-abstract/","title":"Abstract Class Summary","text":""},{"location":"17-abstract/#abstract-class-concept","title":"Abstract Class Concept","text":"<ul> <li>Model an IS-A relationship (<code>Circle</code> IS-A <code>Shape</code>)</li> <li>Declared using <code>abstract</code> keyword</li> <li>Example:   <pre><code>abstract class Shape {\n  abstract double getArea();  // abstract method\n\n  boolean isSymmetric() {     // concrete method\n    return true;\n  }\n}\n</code></pre></li> </ul> <p>Notes:</p> <ul> <li>Abstract class cannot be instantiated</li> <li>Class must be abstract if it has abstract methods</li> <li>Can contain abstract methods, concrete methods and fields</li> <li>Can have no abstract methods</li> <li>Can have constructors for subclasses to call</li> </ul>"},{"location":"17-abstract/#abstract-methods","title":"Abstract Methods","text":"<ul> <li>Methods without implementation</li> <li> <p>Declared using <code>abstract</code> keyword</p> </li> <li> <p>Example:   <pre><code>abstract class Shape {\n  abstract double getArea();  // subclasses must implement\n}\n</code></pre></p> </li> </ul> <p>Notes:</p> <ul> <li>All abstract methods must be implemented by concrete subclasses</li> <li>Abstract methods cannot be private or final</li> <li>Subclasses must override all inherited abstract methods from that abstract class</li> </ul>"},{"location":"17-abstract/#concrete-classes","title":"Concrete Classes","text":"<ul> <li>Classes that implement all abstract methods</li> <li>Can be instantiated</li> <li>Must override all inherited abstract methods</li> <li>Example:   <pre><code>class Circle extends Shape {\n  private double radius;\n\n  @Override\n  double getArea() {  // implements abstract method\n    return Math.PI * radius * radius;\n  }\n}\n</code></pre></li> </ul>"},{"location":"17-abstract/#when-to-use-abstract-classes","title":"When to Use Abstract Classes","text":"<ul> <li>Define common characteristics of related classes</li> <li>Share code among several related classes</li> <li>Want to declare non-public members</li> <li>Need to provide default behavior</li> <li>Example:   <pre><code>abstract class Animal {\n  private String name;\n\n  public Animal(String name) {\n    this.name = name;\n  }\n\n  abstract void makeSound();\n\n  void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n</code></pre></li> </ul>"},{"location":"17-abstract/#best-practices","title":"Best Practices","text":"<ul> <li>Use abstract classes to define base behavior</li> <li>Keep abstract classes focused and cohesive (i.e., all methods and fields should serve a clear purpose)</li> <li>Document expected behavior of abstract methods</li> <li>Consider interfaces for pure abstractions</li> <li>Use meaningful names for abstract classes</li> <li>Provide default implementations when possible</li> </ul>"},{"location":"18-interface/","title":"Interface Summary","text":""},{"location":"18-interface/#interface-concept","title":"Interface Concept","text":"<ul> <li>Specify a contract that defines what methods a class must implement</li> <li>A collection of abstract methods</li> <li>Declared using <code>interface</code> keyword</li> <li>Example:   <pre><code>// Interface defining a contract for objects that have an area\ninterface GetAreable {\n  double getArea();  // implicitly public abstract\n}\n\n\n// Abstract class\nabstract class Shape implements GetAreable {\n  private int numOfAxesOfSymmetry;\n\n  public boolean isSymmetric() {\n    return numOfAxesOfSymmetry &gt; 0;\n  }\n} \n\n// Concrete class\nclass Flat extends RealEstate implements GetAreable {\n  private String block;\n      :\n\n  @Override\n  public double getArea() {\n      :\n  }\n}\n\n// Array with the interface constraints\ndouble findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    } \n  }\n  return maxArea;\n}\n</code></pre></li> </ul> <p>Notes:</p> <ul> <li>All abstract methods in interfaces are <code>public abstract</code> implicitly<ul> <li>Cannot be <code>private</code> or <code>final</code></li> </ul> </li> <li>Non-abstract methods in interfaces must be <code>default</code> or <code>static</code> or <code>private</code></li> <li>All fields in interfaces are <code>public static final</code> implicitly<ul> <li>A compile-time constant</li> <li>Cannot be <code>private</code></li> </ul> </li> <li>Interfaces cannot have constructors</li> <li>Interfaces cannot be instantiated </li> </ul>"},{"location":"18-interface/#implementing-interfaces","title":"Implementing Interfaces","text":"<ul> <li>Classes use <code>implements</code> keyword</li> <li>Example:   <pre><code>class Circle implements GetAreable {\n  @Override\n  public double getArea() {\n    return Math.PI * radius * radius;\n  }\n}\n</code></pre></li> </ul>"},{"location":"18-interface/#multiple-interface-implementation","title":"Multiple Interface Implementation","text":"<ul> <li>Class can <code>implements</code> many interfaces</li> <li>Interfaces can <code>extends</code> one or more interfaces</li> <li>Must implement all methods from all interfaces</li> <li>Example:   <pre><code>class Square implements GetAreable, Comparable&lt;Square&gt; {\n  @Override\n  public double getArea() { return side * side; }\n\n  @Override\n  public int compareTo(Square other) {\n    return Double.compare(this.getArea(), other.getArea());\n  }\n}\n</code></pre></li> </ul>"},{"location":"18-interface/#casting-using-an-interface","title":"Casting Using an Interface","text":"<ul> <li>The compiler allows casting to an interface type because a subclass may implement that interface.</li> <li>However, if the actual object does not implement the interface, a <code>ClassCastException</code> will be thrown at runtime.</li> <li>Example:   <pre><code>interface I {\n  // interface methods\n}\n\nclass A {\n  // class A implementation\n}\n\nclass B implements I {\n  // class B implementation\n}\n</code></pre> <pre><code>I i1 = new B();           // Valid: B implements I, assigned to interface reference\nI i2 = (I) new A();       // Compiles, but throws ClassCastException at runtime (A does not implement I)\nA a = (A) new B();        // Compile-time error: incompatible types\nB b = (B) new A();        // Compile-time error: incompatible types\n</code></pre></li> </ul>"},{"location":"18-interface/#interface-vs-abstract-class","title":"Interface vs Abstract Class","text":"<ul> <li> <p>Interface:</p> <ul> <li>Pure abstraction</li> <li>Multiple implementation</li> <li>No state (instance fields are not allowed)</li> <li>All methods must be public</li> </ul> </li> <li> <p>Abstract Class:</p> <ul> <li>Partial implementation</li> <li>Single inheritance</li> <li>Can have state</li> <li>Abstract methods cannot be private only </li> <li>Concrete methods can be any visibility options</li> </ul> </li> </ul>"},{"location":"18-interface/#best-practices","title":"Best Practices","text":"<ul> <li>Use interfaces to define behavior</li> <li>Keep interfaces focused (single responsibility)</li> <li>Prefer interfaces over abstract classes</li> <li>Use meaningful method names</li> <li>Document expected behavior</li> <li>Consider providing default methods in Java 8+</li> </ul>"},{"location":"19-wrapper/","title":"Wrapper Classes Summary","text":""},{"location":"19-wrapper/#wrapper-class-concept","title":"Wrapper Class Concept","text":"<ul> <li>Classes that encapsulate primitive types</li> <li>Convert primitives to objects</li> <li>Provide utility methods</li> <li>Enable use of primitives in generic code</li> <li>Example:   <pre><code>Integer i = new Integer(42);  // wraps int\nDouble d = new Double(3.14);  // wraps double\n</code></pre></li> </ul>"},{"location":"19-wrapper/#java-wrapper-classes","title":"Java Wrapper Classes","text":"Primitive Wrapper byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean"},{"location":"19-wrapper/#auto-boxing-and-unboxing","title":"Auto-boxing and Unboxing","text":"<ul> <li>Auto-boxing: Automatic primitive to wrapper conversion</li> <li>Unboxing: Automatic wrapper to primitive conversion</li> <li>Example:   <pre><code>Integer i = 42;    // auto-boxing\nint n = i;         // unboxing\n</code></pre></li> </ul>"},{"location":"19-wrapper/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Wrapper objects have overhead</li> <li>Creating new wrapper objects is expensive</li> <li>Example of inefficient code:   <pre><code>Double sum = 0.0;\nfor (int i = 0; i &lt; 1000000; i++) {\n  sum += i;  // creates new Double object each time\n}\n</code></pre></li> </ul>"},{"location":"19-wrapper/#utility-methods","title":"Utility Methods","text":"<ul> <li>Parsing methods</li> <li>Value conversions</li> <li>Comparisons</li> <li>Example:   <pre><code>Integer.parseInt(\"123\");     // String to int\nInteger.toString(123);       // int to String\nInteger.valueOf(\"123\");      // String to Integer\nInteger.compare(1, 2);       // compare two ints\n</code></pre></li> </ul>"},{"location":"19-wrapper/#best-practices","title":"Best Practices","text":"<ul> <li>Use primitives for performance-critical code</li> <li>Use wrappers when objects are required</li> <li>Be aware of auto-boxing overhead</li> <li>Use static utility methods when possible</li> <li>Consider memory usage in collections</li> <li>Avoid null wrapper objects</li> </ul>"},{"location":"20-casting/","title":"Type Casting Summary","text":""},{"location":"20-casting/#run-time-class-mismatch","title":"Run-Time Class Mismatch","text":"<ul> <li>Occurs when actual type doesn't match expected type</li> <li>Can lead to runtime errors</li> <li>Example:   <pre><code>GetAreable[] shapes = new GetAreable[] {\n  new Circle(p, 2),\n  new Square(p, 5)\n};\nCircle c = (Circle) shapes[1];  // Runtime error: Square cannot be cast to Circle\n</code></pre></li> </ul>"},{"location":"20-casting/#type-casting-basics","title":"Type Casting Basics","text":"<ul> <li>Converting between compatible types</li> <li>Must be explicitly done for narrowing conversions</li> <li>Syntax: <code>(Type) expression</code></li> <li>Example:   <pre><code>Shape s = new Circle(p, 1.0);\nCircle c = (Circle) s;  // explicit cast needed\n</code></pre></li> </ul>"},{"location":"20-casting/#safe-casting-practices","title":"Safe Casting Practices","text":"<ul> <li>Always check type before casting</li> <li>Use instanceof operator</li> <li>Example:   <pre><code>if (shape instanceof Circle) {\n  Circle c = (Circle) shape;  // safe cast\n  // use c\n}\n</code></pre></li> </ul>"},{"location":"20-casting/#common-casting-scenarios","title":"Common Casting Scenarios","text":"<ol> <li> <p>Upcasting (Widening):    <pre><code>Circle c = new Circle(p, 1.0);\nShape s = c;  // no cast needed\n</code></pre></p> </li> <li> <p>Downcasting (Narrowing):    <pre><code>Shape s = getShape();\nCircle c = (Circle) s;  // cast needed\n</code></pre></p> </li> </ol>"},{"location":"20-casting/#casting-with-generics","title":"Casting with Generics","text":"<ul> <li>Cannot create generic array</li> <li>Type erasure affects casting</li> <li>Example:   <pre><code>// Not allowed:\nT[] array = new T[10];  // compile error\n\n// Correct way:\nT[] array = (T[]) new Object[10];\n</code></pre></li> </ul>"},{"location":"20-casting/#best-practices","title":"Best Practices","text":"<ul> <li>Minimize use of casting</li> <li>Always validate types before casting</li> <li>Use generics when possible</li> <li>Document casting requirements</li> <li>Handle potential ClassCastException</li> <li>Design to avoid need for casting</li> </ul>"},{"location":"21-variance/","title":"Variance Summary","text":""},{"location":"21-variance/#variance-concepts","title":"Variance Concepts","text":"<ul> <li>Describes subtyping relationships between complex types</li> <li>Three types of variance:<ol> <li>Covariant: If S &lt;: T then C(S) &lt;: C(T)</li> <li>Contravariant: If S &lt;: T then C(T) &lt;: C(S)</li> <li>Invariant: No subtyping relationship</li> </ol> </li> </ul>"},{"location":"21-variance/#java-array-covariance","title":"Java Array Covariance","text":"<ul> <li>Arrays are covariant in Java</li> <li>Can lead to runtime errors</li> <li>Example:   <pre><code>Integer[] intArray = new Integer[2];\nObject[] objArray = intArray;        // OK due to covariance\nobjArray[0] = \"Hello\";              // Runtime error!\n</code></pre></li> </ul>"},{"location":"21-variance/#problems-with-array-covariance","title":"Problems with Array Covariance","text":"<ul> <li>Type safety compromised</li> <li>Runtime errors possible</li> <li>Example of unsafe code:   <pre><code>Shape[] shapes = new Circle[2];    // allowed\nshapes[0] = new Square(1.0);       // runtime error\n</code></pre></li> </ul>"},{"location":"21-variance/#variance-in-generics","title":"Variance in Generics","text":"<ul> <li>Generic types are invariant by default</li> <li>Example:   <pre><code>List&lt;Circle&gt; circles = new ArrayList&lt;&gt;();\nList&lt;Shape&gt; shapes = circles;  // compile error\n</code></pre></li> </ul>"},{"location":"21-variance/#safe-use-of-variance","title":"Safe Use of Variance","text":"<ul> <li>Use generics instead of arrays when possible</li> <li>Be cautious with array covariance</li> <li>Consider using wildcards for flexibility</li> <li>Example:   <pre><code>// Safe generic usage\nList&lt;Circle&gt; circles = new ArrayList&lt;&gt;();\nList&lt;? extends Shape&gt; shapes = circles;  // OK with wildcard\n</code></pre></li> </ul>"},{"location":"21-variance/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer generics over arrays</li> <li>Be aware of array covariance pitfalls</li> <li>Use wildcards appropriately</li> <li>Design for type safety</li> <li>Test edge cases with different types</li> <li>Document variance relationships</li> </ul>"},{"location":"22-exception/","title":"Exceptions Summary","text":""},{"location":"22-exception/#exception-handling-basics","title":"Exception Handling Basics","text":"<ul> <li>Mechanism to handle runtime errors</li> <li>Uses try-catch-finally blocks</li> <li>Allows separation of error handling from main logic</li> <li>Example:   <pre><code>try {\n  // code that might throw exception\n  readFromFile(filename);\n} catch (FileNotFoundException e) {\n  // handle the exception\n  System.err.println(\"File not found: \" + e.getMessage());\n} finally {\n  // cleanup code, always executed\n  closeFile();\n}\n</code></pre></li> </ul>"},{"location":"22-exception/#types-of-exceptions","title":"Types of Exceptions","text":"<ol> <li> <p>Checked Exceptions:</p> <ul> <li>Must be declared or caught</li> <li>Extend Exception class</li> <li>Example: IOException</li> </ul> </li> <li> <p>Unchecked Exceptions:</p> <ul> <li>Don't need to be declared</li> <li>Extend RuntimeException</li> <li>Example: NullPointerException</li> </ul> </li> <li> <p>Errors:</p> <ul> <li>Serious problems</li> <li>Not meant to be caught</li> <li>Example: OutOfMemoryError</li> </ul> </li> </ol>"},{"location":"22-exception/#throwing-exceptions","title":"Throwing Exceptions","text":"<ul> <li>Use throw keyword</li> <li>Can throw new exceptions</li> <li>Must declare checked exceptions</li> <li>Example:   <pre><code>public void readFile(String fileName) throws IOException {\n  throw new IOException(\"File not found\");\n}\n</code></pre></li> </ul>"},{"location":"22-exception/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":"<ul> <li>Extend Exception or RuntimeException</li> <li>Add constructors and fields as needed</li> <li>Example:   <pre><code>class InvalidCircleException extends IllegalArgumentException {\n  public InvalidCircleException(String message) {\n    super(message);\n  }\n}\n</code></pre></li> </ul>"},{"location":"22-exception/#exception-handling-best-practices","title":"Exception Handling Best Practices","text":"<ul> <li>Only catch exceptions you can handle</li> <li>Don't catch and ignore exceptions</li> <li>Clean up resources in finally block</li> <li>Use specific exception types</li> <li>Document exceptions in Javadoc</li> <li>Don't use exceptions for flow control</li> </ul>"},{"location":"22-exception/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<ul> <li>Empty catch blocks</li> <li>Catching Exception (too general)</li> <li>Not cleaning up resources</li> <li>Throwing wrong exception type</li> <li>Example of bad practice:   <pre><code>try {\n  // code\n} catch (Exception e) {\n  // empty catch block - DON'T DO THIS\n}\n</code></pre></li> </ul>"},{"location":"22-exception/#try-with-resources","title":"Try-with-Resources","text":"<ul> <li>Automatically closes resources</li> <li>For classes implementing AutoCloseable</li> <li>Example:   <pre><code>try (FileReader reader = new FileReader(file)) {\n  // use reader\n} catch (IOException e) {\n  // handle exception\n}\n// reader automatically closed\n</code></pre></li> </ul>"},{"location":"23-generics/","title":"Generics Summary","text":""},{"location":"23-generics/#generic-types-concept","title":"Generic Types Concept","text":"<ul> <li>Allow type parameters in class/interface definitions</li> <li>Enable type-safe collections/operations</li> <li>Prevent runtime type errors</li> <li>Example:   <pre><code>class Box&lt;T&gt; {\n  private T item;\n\n  public void put(T item) {\n    this.item = item;\n  }\n\n  public T get() {\n    return item;\n  }\n}\n</code></pre></li> </ul>"},{"location":"23-generics/#type-parameters","title":"Type Parameters","text":"<ul> <li>Commonly used letters:<ul> <li>T for type</li> <li>E for element</li> <li>K for key</li> <li>V for value</li> <li>S,U,V for multiple types</li> </ul> </li> <li>Example:   <pre><code>class Pair&lt;K,V&gt; {\n  private K key;\n  private V value;\n}\n</code></pre></li> </ul>"},{"location":"23-generics/#parameterized-type","title":"Parameterized Type","text":"<ul> <li>A concrete type created by specifying actual types for generic parameters</li> <li>Replaces generic type parameters with real types</li> <li>Creates type-safe class instances</li> <li>Example:   <pre><code>// This is a generic type (not parameterized yet):\nclass Array&lt;T&gt; {    // T is just a placeholder\n  private T[] elements;\n}\n\n// These are parameterized types:\nArray&lt;String&gt; words = new Array&lt;&gt;();     // T becomes String\nclass StringArray extends Array&lt;String&gt; { } // Array&lt;T&gt; is instantiated as Array&lt;String&gt;\n\n// Invalid parameterized type examples:\n// class Array&lt;String&gt; { }    // ERROR: Cannot use concrete type in class definition\n// Array&lt;int&gt; numbers;        // ERROR: Cannot use primitive types\n// Array&lt;T&gt; generic;          // ERROR: T is not defined in this context\n</code></pre></li> </ul>"},{"location":"23-generics/#bounded-type-parameters","title":"Bounded Type Parameters","text":"<ul> <li>Restrict type parameters to certain types</li> <li>Use extends keyword</li> <li>Can bound to class or interface</li> <li>Example:   <pre><code>class NumberBox&lt;T extends Number&gt; {\n  private T number;\n\n  public double getValue() {\n    return number.doubleValue();  // OK because T extends Number\n  }\n}\n</code></pre></li> </ul>"},{"location":"23-generics/#generic-methods","title":"Generic Methods","text":"<ul> <li>Methods with their own type parameters</li> <li>Type parameter before return type</li> <li>Example:   <pre><code>public static &lt;T&gt; void printArray(T[] array) {\n  for (T element : array) {\n    System.out.println(element);\n  }\n}\n</code></pre></li> </ul>"},{"location":"23-generics/#type-inference","title":"Type Inference","text":"<ul> <li>Java can infer type arguments</li> <li>Diamond operator &lt;&gt; for constructors</li> <li>Example:   <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();  // type inferred\nBox&lt;Integer&gt; box = new Box&lt;&gt;();         // type inferred\n</code></pre></li> </ul>"},{"location":"23-generics/#generic-type-restrictions","title":"Generic Type Restrictions","text":"<ul> <li>Cannot create arrays of generic types</li> <li>Cannot create generic exceptions</li> <li>Cannot use primitives directly</li> <li>Example:   <pre><code>// Not allowed:\nT[] array = new T[10];  // compile error\n\n// Use this instead:\nT[] array = (T[]) new Object[10];\n</code></pre></li> </ul>"},{"location":"23-generics/#best-practices","title":"Best Practices","text":"<ul> <li>Use generics for type safety</li> <li>Prefer bounded wildcards for flexibility</li> <li>Document type parameter meanings</li> <li>Keep type parameter names meaningful</li> <li>Use generic collections over raw types</li> <li>Consider type erasure implications</li> </ul>"},{"location":"24-erasure/","title":"Type Erasure Summary","text":""},{"location":"24-erasure/#type-erasure-concept","title":"Type Erasure Concept","text":"<ul> <li>Java's implementation of generics</li> <li>Removes type parameters at compile time</li> <li>Replaces with Object or bounds</li> <li>Maintains backward compatibility</li> <li>Example:   <pre><code>// Before erasure\nclass Box&lt;T&gt; {\n  private T item;\n}\n\n// After erasure\nclass Box {\n  private Object item;  // T replaced with Object\n}\n</code></pre></li> </ul>"},{"location":"24-erasure/#how-erasure-works","title":"How Erasure Works","text":"<ul> <li>Replaces type parameters with Object</li> <li>Replaces bounded types with first bound</li> <li>Adds type casts where necessary</li> <li>Example:   <pre><code>// Before erasure\nBox&lt;String&gt; box = new Box&lt;&gt;();\nString s = box.get();\n\n// After erasure\nBox box = new Box();\nString s = (String) box.get();\n</code></pre></li> </ul>"},{"location":"24-erasure/#erasure-with-bounds","title":"Erasure with Bounds","text":"<ul> <li>Bounded type replaced with bound</li> <li>Example:   <pre><code>// Before erasure\nclass NumberBox&lt;T extends Number&gt; {\n  private T number;\n}\n\n// After erasure\nclass NumberBox {\n  private Number number;  // T replaced with Number\n}\n</code></pre></li> </ul>"},{"location":"24-erasure/#arrays-and-generics","title":"Arrays and Generics","text":"<ul> <li>Cannot create arrays of generic types</li> <li>Type information lost at runtime</li> <li>Can lead to heap pollution</li> <li>Example:   <pre><code>// Not allowed:\nT[] array = new T[10];\n\n// Common workaround:\nT[] array = (T[]) new Object[10];\n</code></pre></li> </ul>"},{"location":"24-erasure/#reifiable-types","title":"Reifiable Types","text":"<ul> <li>Types with runtime information available</li> <li>Includes:<ul> <li>Primitive types</li> <li>Non-generic types</li> <li>Raw types</li> <li>Unbounded wildcards</li> </ul> </li> <li>Example:   <pre><code>// Reifiable\nString[] strings = new String[10];\nList&lt;?&gt; list = new ArrayList&lt;&gt;();\n\n// Not reifiable\nList&lt;String&gt;[] arrayOfLists;  // compile error\n</code></pre></li> </ul>"},{"location":"24-erasure/#best-practices","title":"Best Practices","text":"<ul> <li>Be aware of type erasure limitations</li> <li>Use runtime type tokens when needed</li> <li>Avoid mixing arrays and generics</li> <li>Document type erasure implications</li> <li>Use collections over arrays with generics</li> <li>Consider reifiable type alternatives</li> </ul>"},{"location":"25-unchecked/","title":"Unchecked Warnings Summary","text":""},{"location":"25-unchecked/#unchecked-warnings-concept","title":"Unchecked Warnings Concept","text":"<ul> <li>Compiler warnings about type safety</li> <li>Related to generic type operations</li> <li>Indicates potential runtime errors</li> <li>Example:   <pre><code>List list = new ArrayList&lt;String&gt;();  // unchecked warning\nlist.add(\"hello\");                    // unchecked warning\n</code></pre></li> </ul>"},{"location":"25-unchecked/#common-unchecked-scenarios","title":"Common Unchecked Scenarios","text":"<ol> <li> <p>Raw Types:    <pre><code>List list = new ArrayList&lt;String&gt;();  // using raw type\n</code></pre></p> </li> <li> <p>Type Casting:    <pre><code>T[] array = (T[]) new Object[10];  // unchecked cast\n</code></pre></p> </li> <li> <p>Generic Array Creation:    <pre><code>List&lt;String&gt;[] array;  // generic array creation \n</code></pre></p> </li> </ol>"},{"location":"25-unchecked/#suppresswarnings","title":"@SuppressWarnings","text":"<ul> <li>Annotation to suppress warnings</li> <li>Use sparingly and with justification</li> <li>Document why suppression is safe</li> <li>Example:   <pre><code>@SuppressWarnings(\"unchecked\")\npublic static &lt;T&gt; T[] createArray(Class&lt;T&gt; type, int size) {\n  return (T[]) new Object[size];\n}\n</code></pre></li> </ul>"},{"location":"25-unchecked/#safe-generic-array-creation","title":"Safe Generic Array Creation","text":"<ul> <li>Use ArrayList instead of arrays</li> <li>Create Object array and cast</li> <li>Document type safety</li> <li>Example:   <pre><code>// Instead of T[] array:\nList&lt;T&gt; list = new ArrayList&lt;&gt;();\n\n// Or if array needed:\n@SuppressWarnings(\"unchecked\")\nT[] array = (T[]) new Object[size];\n</code></pre></li> </ul>"},{"location":"25-unchecked/#raw-types","title":"Raw Types","text":"<ul> <li>Types without type parameters</li> <li>Should be avoided</li> <li>Legacy from pre-generic Java</li> <li>Example:   <pre><code>// Don't use:\nList list = new ArrayList();\n\n// Use instead:\nList&lt;Object&gt; list = new ArrayList&lt;&gt;();\n</code></pre></li> </ul>"},{"location":"25-unchecked/#best-practices","title":"Best Practices","text":"<ul> <li>Address warnings when possible</li> <li>Document suppressed warnings</li> <li>Use most specific scope for @SuppressWarnings</li> <li>Avoid raw types</li> <li>Test type safety thoroughly</li> <li>Consider alternative designs</li> </ul>"},{"location":"26-wildcard/","title":"Wildcards Summary","text":""},{"location":"26-wildcard/#wildcard-types","title":"Wildcard Types","text":"<ul> <li>Represented by <code>?</code></li> <li>Three types of wildcards:<ol> <li>Upper Bounded: <code>&lt;? extends Type&gt;</code></li> <li>Lower Bounded: <code>&lt;? super Type&gt;</code></li> <li>Unbounded: <code>&lt;?&gt;</code></li> </ol> </li> </ul>"},{"location":"26-wildcard/#upper-bounded-wildcards","title":"Upper Bounded Wildcards","text":"<ul> <li>Accepts type and its subtypes</li> <li>Used for reading from structure</li> <li>Example:   <pre><code>void printShapes(List&lt;? extends Shape&gt; shapes) {\n  for (Shape s : shapes) {\n    System.out.println(s.getArea());\n  }\n}\n</code></pre></li> </ul>"},{"location":"26-wildcard/#lower-bounded-wildcards","title":"Lower Bounded Wildcards","text":"<ul> <li>Accepts type and its supertypes</li> <li>Used for writing to structure</li> <li>Example:   <pre><code>void addCircles(List&lt;? super Circle&gt; list) {\n  list.add(new Circle());\n  list.add(new Circle(1.0));\n}\n</code></pre></li> </ul>"},{"location":"26-wildcard/#pecs-principle","title":"PECS Principle","text":"<ul> <li>Producer Extends, Consumer Super</li> <li>Use extends for input (reading)</li> <li>Use super for output (writing)</li> <li>Example:   <pre><code>// Producer (extends) - reading from source\nvoid copyFromSource(List&lt;? extends Shape&gt; source) {\n  Shape s = source.get(0);  // OK\n}\n\n// Consumer (super) - writing to dest\nvoid copyToDest(List&lt;? super Circle&gt; dest) {\n  dest.add(new Circle());  // OK\n}\n</code></pre></li> </ul>"},{"location":"26-wildcard/#unbounded-wildcards","title":"Unbounded Wildcards","text":"<ul> <li>Represented by <code>&lt;?&gt;</code></li> <li>Used when actual type doesn't matter</li> <li>Example:   <pre><code>void printList(List&lt;?&gt; list) {\n  for (Object o : list) {\n    System.out.println(o);\n  }\n}\n</code></pre></li> </ul>"},{"location":"26-wildcard/#wildcard-capture","title":"Wildcard Capture","text":"<ul> <li>Compiler captures unknown type</li> <li>Used in helper methods</li> <li>Example:   <pre><code>public void swap(List&lt;?&gt; list, int i, int j) {\n  swapHelper(list, i, j);  // helper method\n}\n\nprivate &lt;T&gt; void swapHelper(List&lt;T&gt; list, int i, int j) {\n  T temp = list.get(i);\n  list.set(i, list.get(j));\n  list.set(j, temp);\n}\n</code></pre></li> </ul>"},{"location":"26-wildcard/#best-practices","title":"Best Practices","text":"<ul> <li>Use PECS principle</li> <li>Prefer wildcards over type parameters</li> <li>Use unbounded wildcards for Object methods</li> <li>Document wildcard usage</li> <li>Consider readability vs flexibility</li> <li>Test with different type hierarchies</li> </ul>"},{"location":"27-inference/","title":"Type Inference Summary","text":""},{"location":"27-inference/#type-inference-concept","title":"Type Inference Concept","text":"<ul> <li>Compiler determines types automatically</li> <li>Reduces verbosity in generic code</li> <li>Based on context and type constraints</li> <li>Example:   <pre><code>// Without type inference\nList&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n// With type inference\nList&lt;String&gt; list = new ArrayList&lt;&gt;();  // diamond operator\n</code></pre></li> </ul>"},{"location":"27-inference/#diamond-operator","title":"Diamond Operator","text":"<ul> <li>Used in constructor calls</li> <li>Infers type from declaration</li> <li>Example:   <pre><code>Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\nPair&lt;Double, String&gt; pair = new Pair&lt;&gt;();\n</code></pre></li> </ul>"},{"location":"27-inference/#method-type-inference","title":"Method Type Inference","text":"<ul> <li>Infers type arguments for generic methods</li> <li>Based on:<ul> <li>Method arguments</li> <li>Return type context</li> <li>Type constraints</li> </ul> </li> <li>Example:   <pre><code>static &lt;T&gt; List&lt;T&gt; asList(T... elements) {\n  return Arrays.asList(elements);\n}\n\nList&lt;String&gt; list = asList(\"a\", \"b\", \"c\");  // T inferred as String\n</code></pre></li> </ul>"},{"location":"27-inference/#target-typing","title":"Target Typing","text":"<ul> <li>Uses assignment context for inference</li> <li>Considers variable type</li> <li>Example:   <pre><code>List&lt;String&gt; strings = Collections.emptyList();  // infers List&lt;String&gt;\nvoid process(List&lt;Integer&gt; ints) { }\nprocess(Collections.emptyList());  // infers List&lt;Integer&gt;\n</code></pre></li> </ul>"},{"location":"27-inference/#type-inference-rules","title":"Type Inference Rules","text":"<ul> <li>Most specific type is chosen</li> <li>Must satisfy all constraints</li> <li>Example:   <pre><code>// T must be supertype of both String and Integer\n&lt;T&gt; void addToList(List&lt;T&gt; list, T item1, T item2) { }\nList&lt;Object&gt; list = new ArrayList&lt;&gt;();\naddToList(list, \"hello\", 42);  // T inferred as Object\n</code></pre></li> </ul>"},{"location":"27-inference/#best-practices","title":"Best Practices","text":"<ul> <li>Use diamond operator</li> <li>Let compiler infer types when clear</li> <li>Provide explicit types when needed</li> <li>Test inference with edge cases</li> <li>Document when inference is complex</li> <li>Consider readability vs brevity</li> </ul>"},{"location":"28-immutability/","title":"Immutability Summary","text":""},{"location":"28-immutability/#aliasing","title":"Aliasing","text":"<ul> <li>Multiple references pointing to the same object</li> <li>Changes through one reference affect all references</li> <li>Can lead to unexpected behavior</li> <li> <p>Example:   <pre><code>List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\nList&lt;Integer&gt; list2 = list1;  // alias created\nlist1.add(1);  // affects both list1 and list2\n</code></pre></p> </li> <li> <p>Common Issues:</p> </li> <li>Unintended modifications</li> <li>Debugging complexity</li> <li>Concurrency challenges</li> </ul>"},{"location":"28-immutability/#immutability-concept","title":"Immutability Concept","text":"<ul> <li>Objects cannot be modified after creation</li> <li>All fields are final</li> <li>No mutator methods</li> <li>Returns new objects for modifications</li> <li>Example:   <pre><code>final class Point {\n  private final double x;\n  private final double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public Point moveTo(double newX, double newY) {\n    return new Point(newX, newY);  // returns new instance\n  }\n}\n</code></pre></li> </ul>"},{"location":"28-immutability/#benefits-of-immutability","title":"Benefits of Immutability","text":"<ol> <li> <p>Thread Safety:</p> <ul> <li>Safe for concurrent access</li> <li>No synchronization needed</li> </ul> </li> <li> <p>Easier Reasoning:</p> <ul> <li>No state changes to track</li> <li>Predictable behavior</li> </ul> </li> <li> <p>Security:</p> <ul> <li>Cannot be modified maliciously</li> <li>Safe to share references</li> </ul> </li> <li> <p>Caching:</p> <ul> <li>Can cache safely</li> <li>No invalidation needed</li> </ul> </li> </ol>"},{"location":"28-immutability/#creating-immutable-classes","title":"Creating Immutable Classes","text":"<ol> <li>Make class final</li> <li>Make fields private and final</li> <li>No setter methods</li> <li>Return new instances for modifications</li> <li>Protect mutable fields</li> <li>Example:   <pre><code>final class Circle {\n  private final Point center;\n  private final double radius;\n\n  public Circle(Point center, double radius) {\n    this.center = new Point(center.getX(), center.getY());  // defensive copy\n    this.radius = radius;\n  }\n\n  public Point getCenter() {\n    return new Point(center.getX(), center.getY());  // return copy\n  }\n}\n</code></pre></li> </ol>"},{"location":"28-immutability/#copy-on-write-pattern","title":"Copy-on-Write Pattern","text":"<ul> <li>Create new object for modifications</li> <li>Share unmodified objects</li> <li>Example:   <pre><code>public Circle resize(double factor) {\n  return new Circle(this.center, this.radius * factor);\n}\n</code></pre></li> </ul>"},{"location":"28-immutability/#best-practices","title":"Best Practices","text":"<ul> <li>Make classes immutable by default</li> <li>Use final liberally</li> <li>Create defensive copies</li> <li>Document immutability</li> <li>Consider performance implications</li> <li>Use factory methods for flexibility</li> </ul>"},{"location":"29-nested-classes/","title":"Nested Classes Summary","text":""},{"location":"29-nested-classes/#types-of-nested-classes","title":"Types of Nested Classes","text":"<ol> <li>Inner Classes</li> <li>Static Nested Classes</li> <li>Local Classes</li> <li>Anonymous Classes</li> </ol>"},{"location":"29-nested-classes/#inner-classes","title":"Inner Classes","text":"<ul> <li>Has access to all outer class members</li> <li>Requires instance of outer class</li> <li>Example:   <pre><code>class Outer {\n  private int x;\n  static int y;\n\n  class Inner {\n    private int x;\n\n    void method() {\n      A1.this.x = 1; // instance field\n      A1.y = 1; //static field\n      this.x // field in inner class\n    }\n  }\n}\n</code></pre></li> </ul>"},{"location":"29-nested-classes/#static-nested-classes","title":"Static Nested Classes","text":"<ul> <li>Declared with static modifier</li> <li>Cannot access instance members of outer class</li> <li>Example:   <pre><code>class Outer {\n  private static int x;\n\n  static class StaticNested {\n    void method() {\n      x = 1;  // can access static members\n    }\n  }\n}\n</code></pre></li> </ul>"},{"location":"29-nested-classes/#local-classes","title":"Local Classes","text":"<ul> <li>Defined inside methods</li> <li>Can access local variables (must be final/effectively final)</li> <li>Example:   <pre><code>void method() {\n  final int x = 1;\n  class Local {\n    void innerMethod() {\n      System.out.println(x);  // can access final local vars\n    }\n  }\n}\n</code></pre></li> </ul>"},{"location":"29-nested-classes/#anonymous-classes","title":"Anonymous Classes","text":"<ul> <li>Class definition and instantiation combined</li> <li>Often used for interfaces/abstract classes</li> <li> <p>Example - Implementing an Interface   <pre><code>interface A {\n  void show();\n}\n\npublic class Test {\n  public static void main(String[] args) {\n    A obj = new A() {\n      public void show() {\n        System.out.println(\"Hello from anonymous class\");\n      }\n    };\n    obj.show();\n  }\n}\n</code></pre></p> </li> <li> <p>Example - Extending a Class   <pre><code>class Animal {\n  void makeSound() {\n    System.out.println(\"Some sound\");\n  }\n}\n\npublic class Test {\n  public static void main(String[] args) {\n    Animal dog = new Animal() {\n      void makeSound() {\n        System.out.println(\"Bark\");\n      }\n    };\n    dog.makeSound();\n  }\n}\n</code></pre></p> </li> <li> <p>Example - Generic Types   <pre><code>abstract class Generic&lt;T&gt; {\n  abstract void display(T value);\n}\n\npublic class Test {\n  public static void main(String[] args) {\n    Generic&lt;Integer&gt; obj = new Generic&lt;&gt;() {\n      void display(Integer value) {\n        System.out.println(\"Value: \" + value);\n      }\n    };\n    obj.display(100);\n  }\n}\n</code></pre></p> </li> </ul>"},{"location":"29-nested-classes/#variable-capture","title":"Variable Capture","text":"<ul> <li>Local and anonymous classes can capture variables</li> <li>Variables must be final or effectively final</li> <li>Example:   <pre><code>void method() {\n  final int x = 1;\n  Runnable r = new Runnable() {\n    @Override\n    public void run() {\n      System.out.println(x);  // captures x\n    }\n  };\n}\n</code></pre></li> </ul>"},{"location":"29-nested-classes/#best-practices","title":"Best Practices","text":"<ul> <li>Use static nested classes when possible</li> <li>Keep inner classes small and focused</li> <li>Consider lambda expressions instead of anonymous classes</li> <li>Be careful with variable capture</li> <li>Document nested class relationships</li> <li>Use nested classes for encapsulation</li> </ul>"},{"location":"30-functions/","title":"Functions Summary","text":""},{"location":"30-functions/#pure-functions","title":"Pure Functions","text":"<ul> <li>No side effects</li> <li>Same input always gives same output</li> <li>Deterministic behavior</li> <li>Example:   <pre><code>int square(int x) {\n  return x * x;  // pure function\n}\n</code></pre></li> </ul>"},{"location":"30-functions/#first-class-functions","title":"First-Class Functions","text":"<ul> <li>Functions as values</li> <li>Can be passed as arguments</li> <li>Can be returned from methods</li> <li>Can be stored in variables</li> <li>Example:   <pre><code>interface Transformer&lt;T,R&gt; {\n  R transform(T t);\n}\n\nTransformer&lt;Integer,Integer&gt; square = x -&gt; x * x;\n</code></pre></li> </ul>"},{"location":"30-functions/#lambda-expressions","title":"Lambda Expressions","text":"<ul> <li>Anonymous function syntax</li> <li>Concise method definitions</li> <li>Used with functional interfaces</li> <li>Example:   <pre><code>// Lambda syntax variations\nx -&gt; x + 1                    // single parameter\n(x, y) -&gt; x + y              // multiple parameters\n(String s) -&gt; s.length()     // with type\nx -&gt; { return x * x; }       // with block\n</code></pre></li> </ul>"},{"location":"30-functions/#method-references","title":"Method References","text":"<ul> <li>Shorthand for lambdas</li> <li>References existing methods</li> <li>Four types:<ol> <li>Static methods</li> <li>Instance methods</li> <li>Constructor references</li> <li>Arbitrary object methods</li> </ol> </li> <li>Example:   <pre><code>String::length              // instance method\nSystem.out::println        // instance method\nInteger::parseInt         // static method\nArrayList::new           // constructor\n</code></pre></li> </ul>"},{"location":"30-functions/#currying","title":"Currying","text":"<ul> <li>Converting n-ary function to sequence of unary functions</li> <li>Enables partial application</li> <li>Example:   <pre><code>// Instead of:\nint add(int x, int y) {\n  return x + y;\n}\n\n// Curried version:\nFunction&lt;Integer, Function&lt;Integer, Integer&gt;&gt; \n  curriedAdd = x -&gt; y -&gt; x + y;\n</code></pre></li> </ul>"},{"location":"30-functions/#closures","title":"Closures","text":"<ul> <li>Functions that capture their environment</li> <li>Access to non-local variables</li> <li>Example:   <pre><code>int multiplier = 10;\nTransformer&lt;Integer,Integer&gt; times = x -&gt; x * multiplier;\n</code></pre></li> </ul>"},{"location":"30-functions/#best-practices","title":"Best Practices","text":"<ul> <li>Prefer pure functions</li> <li>Use meaningful names</li> <li>Keep functions small and focused</li> <li>Document behavior</li> <li>Consider composability</li> <li>Handle edge cases</li> <li>Test thoroughly</li> </ul>"},{"location":"31-box-maybe/","title":"Box and Maybe Summary","text":""},{"location":"31-box-maybe/#box-concept","title":"Box Concept <ul> <li>Generic container for a single value</li> <li>Provides abstraction barrier</li> <li>Enables functional operations</li> <li>Example:   <pre><code>class Box&lt;T&gt; {\n  private final T item;\n\n  private Box(T item) {\n    this.item = item;\n  }\n\n  public static &lt;T&gt; Box&lt;T&gt; of(T item) {\n    return new Box&lt;&gt;(item);\n  }\n}\n</code></pre></li> </ul>","text":""},{"location":"31-box-maybe/#maybe-concept","title":"Maybe Concept <ul> <li>Represents optional values</li> <li>Handles null cases safely</li> <li>Two variants: Some and None</li> <li>Example:   <pre><code>abstract class Maybe&lt;T&gt; {\n  private Maybe() { }\n\n  public static &lt;T&gt; Maybe&lt;T&gt; some(T value) {\n    return new Some&lt;&gt;(value);\n  }\n\n  public static &lt;T&gt; Maybe&lt;T&gt; none() {\n    return new None&lt;&gt;();\n  }\n}\n</code></pre></li> </ul>","text":""},{"location":"31-box-maybe/#map-and-flatmap","title":"Map and FlatMap <ul> <li>Map transforms content</li> <li>FlatMap handles nested containers</li> <li>Example:   <pre><code>// Map example\nMaybe&lt;String&gt; name = Maybe.some(\"hello\");\nMaybe&lt;Integer&gt; length = name.map(s -&gt; s.length());\n\n// FlatMap example\nMaybe&lt;Maybe&lt;String&gt;&gt; nested = Maybe.some(Maybe.some(\"hello\"));\nMaybe&lt;String&gt; flattened = nested.flatMap(x -&gt; x);\n</code></pre></li> </ul>","text":""},{"location":"31-box-maybe/#null-safety","title":"Null Safety <ul> <li>Avoids NullPointerException</li> <li>Makes null checks explicit</li> <li>Example:   <pre><code>// Instead of:\nString s = getStringMaybeNull();\nif (s != null) {\n  System.out.println(s.length());\n}\n\n// Using Maybe:\nMaybe&lt;String&gt; s = getStringMaybe();\ns.map(str -&gt; str.length())\n .ifPresent(System.out::println);\n</code></pre></li> </ul>","text":""},{"location":"31-box-maybe/#functional-operations","title":"Functional Operations <ul> <li>filter: Conditionally keep values</li> <li>map: Transform values</li> <li>flatMap: Handle nested Maybes</li> <li>Example:   <pre><code>Maybe&lt;Integer&gt; result = Maybe.some(42)\n  .filter(x -&gt; x &gt; 0)\n  .map(x -&gt; x * 2)\n  .flatMap(x -&gt; Maybe.some(x + 1));\n</code></pre></li> </ul>","text":""},{"location":"31-box-maybe/#best-practices","title":"Best Practices <ul> <li>Use Maybe for optional values</li> <li>Chain operations functionally</li> <li>Avoid null checks</li> <li>Handle both Some and None cases</li> <li>Document Maybe usage</li> <li>Consider performance implications</li> </ul>","text":""},{"location":"32-lazy/","title":"Lazy Evaluation Summary","text":""},{"location":"32-lazy/#lazy-evaluation-concept","title":"Lazy Evaluation Concept","text":"<ul> <li>Delays computation until needed</li> <li>Avoids unnecessary calculations</li> <li>Can improve performance</li> <li>Example:   <pre><code>class Lazy&lt;T&gt; {\n  private T value;\n  private boolean evaluated;\n  private Producer&lt;T&gt; producer;\n\n  public Lazy(Producer&lt;T&gt; producer) {\n    this.producer = producer;\n    this.evaluated = false;\n  }\n}\n</code></pre></li> </ul>"},{"location":"32-lazy/#memoization","title":"Memoization","text":"<ul> <li>Caches computed results</li> <li>Computes only once</li> <li>Reuses cached value</li> <li>Example:   <pre><code>public T get() {\n  if (!evaluated) {\n    value = producer.produce();\n    evaluated = true;\n  }\n  return value;\n}\n</code></pre></li> </ul>"},{"location":"32-lazy/#lazy-operations","title":"Lazy Operations","text":"<ul> <li>map: Transform value lazily</li> <li>flatMap: Chain lazy computations</li> <li>Example:   <pre><code>Lazy&lt;Integer&gt; lazyNum = new Lazy&lt;&gt;(() -&gt; expensiveComputation());\nLazy&lt;String&gt; lazyStr = lazyNum.map(n -&gt; n.toString());\n</code></pre></li> </ul>"},{"location":"32-lazy/#benefits-of-lazy-evaluation","title":"Benefits of Lazy Evaluation","text":"<ol> <li> <p>Performance:</p> <ul> <li>Avoids unnecessary computations</li> <li>Saves resources</li> </ul> </li> <li> <p>Infinite Structures:</p> <ul> <li>Can represent infinite sequences</li> <li>Only computes needed values</li> </ul> </li> <li> <p>Short-circuit Evaluation:</p> <ul> <li>Stops when result is determined</li> <li>Avoids redundant work</li> </ul> </li> </ol>"},{"location":"32-lazy/#practical-applications","title":"Practical Applications","text":"<ul> <li>Logging systems</li> <li>Configuration loading</li> <li>Database queries</li> <li>Example:   <pre><code>Lazy&lt;String&gt; log = new Lazy&lt;&gt;(() -&gt; \n  \"User \" + expensiveUserLookup() + \" logged in\");\n\nif (debugEnabled) {\n  System.out.println(log.get());  // only computed if needed\n}\n</code></pre></li> </ul>"},{"location":"32-lazy/#best-practices","title":"Best Practices","text":"<ul> <li>Use for expensive computations</li> <li>Implement memoization</li> <li>Consider thread safety</li> <li>Document lazy behavior</li> <li>Handle exceptions properly</li> <li>Test both lazy and eager paths</li> </ul>"},{"location":"33-infinitelist/","title":"Infinite List Summary","text":""},{"location":"33-infinitelist/#infinitelist-concept","title":"InfiniteList Concept","text":"<ul> <li>Represents potentially infinite sequences</li> <li>Lazily evaluated</li> <li>Uses head/tail structure</li> <li>Example:   <pre><code>class InfiniteList&lt;T&gt; {\n  private final Producer&lt;T&gt; head;\n  private final Producer&lt;InfiniteList&lt;T&gt;&gt; tail;\n\n  public InfiniteList(Producer&lt;T&gt; head, \n      Producer&lt;InfiniteList&lt;T&gt;&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n}\n</code></pre></li> </ul>"},{"location":"33-infinitelist/#creating-infinite-lists","title":"Creating Infinite Lists","text":"<ol> <li> <p>Generate Method:    <pre><code>public static &lt;T&gt; InfiniteList&lt;T&gt; generate(Producer&lt;T&gt; producer) {\n  return new InfiniteList&lt;&gt;(producer,\n      () -&gt; generate(producer));\n}\n</code></pre></p> </li> <li> <p>Iterate Method:    <pre><code>public static &lt;T&gt; InfiniteList&lt;T&gt; iterate(T seed, \n    Transformer&lt;T,T&gt; next) {\n  return new InfiniteList&lt;&gt;(() -&gt; seed,\n      () -&gt; iterate(next.transform(seed), next));\n}\n</code></pre></p> </li> </ol>"},{"location":"33-infinitelist/#operations-on-infinitelist","title":"Operations on InfiniteList","text":"<ul> <li>map: Transform elements</li> <li>filter: Select elements</li> <li>limit: Take first n elements</li> <li>Example:   <pre><code>InfiniteList&lt;Integer&gt; numbers = InfiniteList\n  .iterate(0, x -&gt; x + 1)     // 0,1,2,3,...\n  .filter(x -&gt; x % 2 == 0)    // 0,2,4,6,...\n  .map(x -&gt; x * x)            // 0,4,16,36,...\n  .limit(5);                  // first 5 elements\n</code></pre></li> </ul>"},{"location":"33-infinitelist/#lazy-evaluation-benefits","title":"Lazy Evaluation Benefits","text":"<ul> <li>Memory efficient</li> <li>Handles infinite sequences</li> <li>Computes only needed values</li> <li>Example:   <pre><code>InfiniteList&lt;Integer&gt; primes = InfiniteList\n  .iterate(2, n -&gt; n + 1)\n  .filter(n -&gt; isPrime(n));  // only checks primality when needed\n</code></pre></li> </ul>"},{"location":"33-infinitelist/#implementation-details","title":"Implementation Details","text":"<ul> <li>Head and tail are producers</li> <li>Evaluation happens on demand</li> <li>Memoization for efficiency</li> <li>Example:   <pre><code>public T head() {\n  return head.produce();  // evaluated only when called\n}\n\npublic InfiniteList&lt;T&gt; tail() {\n  return tail.produce();  // evaluated only when called\n}\n</code></pre></li> </ul>"},{"location":"33-infinitelist/#best-practices","title":"Best Practices","text":"<ul> <li>Use lazy operations</li> <li>Implement memoization</li> <li>Handle termination cases</li> <li>Consider memory usage</li> <li>Document infinite behavior</li> <li>Test with finite prefixes</li> </ul>"},{"location":"34-stream/","title":"Java Stream Summary","text":""},{"location":"34-stream/#stream-concept","title":"Stream Concept","text":"<ul> <li>Sequence of elements</li> <li>Supports sequential/parallel operations</li> <li>Lazy evaluation</li> <li>Example:   <pre><code>Stream&lt;String&gt; stream = Stream.of(\"a\", \"b\", \"c\");\nList&lt;String&gt; result = stream\n  .map(String::toUpperCase)\n  .collect(Collectors.toList());\n</code></pre></li> </ul>"},{"location":"34-stream/#creating-streams","title":"Creating Streams","text":"<ol> <li> <p>From Collection:    <pre><code>List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\");\nStream&lt;String&gt; stream = list.stream();\n</code></pre></p> </li> <li> <p>Static Factory Methods:    <pre><code>Stream&lt;Integer&gt; stream1 = Stream.of(1, 2, 3);\nStream&lt;Integer&gt; stream2 = Stream.iterate(0, n -&gt; n + 1);\nStream&lt;String&gt; stream3 = Stream.generate(() -&gt; \"hello\");\n</code></pre></p> </li> </ol>"},{"location":"34-stream/#stream-operations","title":"Stream Operations","text":"<ol> <li> <p>Intermediate Operations:</p> <ul> <li>map: Transform elements</li> <li>filter: Select elements</li> <li>flatMap: One-to-many transformation</li> <li>sorted: Sort elements</li> <li>distinct: Remove duplicates    <pre><code>stream.filter(x -&gt; x &gt; 0)\n     .map(x -&gt; x * 2)\n     .sorted()\n</code></pre></li> </ul> </li> <li> <p>Terminal Operations:</p> <ul> <li>collect: Accumulate elements</li> <li>forEach: Process elements</li> <li>reduce: Combine elements</li> <li>count: Count elements    <pre><code>int sum = stream.reduce(0, Integer::sum);\nlong count = stream.count();\n</code></pre></li> </ul> </li> </ol>"},{"location":"34-stream/#parallel-streams","title":"Parallel Streams","text":"<ul> <li>Automatic parallelization</li> <li>Use multiple threads</li> <li>Example:   <pre><code>list.parallelStream()\n    .filter(x -&gt; x &gt; 0)\n    .map(x -&gt; x * 2)\n    .collect(Collectors.toList());\n</code></pre></li> </ul>"},{"location":"34-stream/#stream-characteristics","title":"Stream Characteristics","text":"<ul> <li>Single use only</li> <li>Lazy evaluation</li> <li>Non-interference required</li> <li>Stateless preferred</li> <li>Example:   <pre><code>Stream&lt;String&gt; stream = list.stream();\nstream.forEach(System.out::println);\nstream.forEach(System.out::println);  // IllegalStateException\n</code></pre></li> </ul>"},{"location":"34-stream/#best-practices","title":"Best Practices","text":"<ul> <li>Use streams for data processing</li> <li>Consider parallel streams for large datasets</li> <li>Avoid stateful operations</li> <li>Handle stream closure properly</li> <li>Use appropriate collectors</li> <li>Consider performance implications</li> </ul>"},{"location":"35-logger/","title":"Logger (Loggable) Summary","text":""},{"location":"35-logger/#loggable-concept","title":"Loggable Concept","text":"<ul> <li>Encapsulates value with logging information</li> <li>Maintains operation history</li> <li>Functional approach to logging</li> <li>Example:   <pre><code>class Loggable&lt;T&gt; {\n  private final T value;\n  private final String log;\n\n  private Loggable(T value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n}\n</code></pre></li> </ul>"},{"location":"35-logger/#creating-loggable","title":"Creating Loggable","text":"<ul> <li>Static factory method</li> <li>Initialize with empty log</li> <li>Example:   <pre><code>public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n  return new Loggable&lt;&gt;(value, \"\");\n}\n</code></pre></li> </ul>"},{"location":"35-logger/#functional-operations","title":"Functional Operations","text":"<ol> <li> <p>Map:    <pre><code>public &lt;U&gt; Loggable&lt;U&gt; map(Transformer&lt;? super T, ? extends U&gt; transformer) {\n  return new Loggable&lt;&gt;(\n    transformer.transform(this.value),\n    this.log\n  );\n}\n</code></pre></p> </li> <li> <p>FlatMap:    <pre><code>public &lt;U&gt; Loggable&lt;U&gt; flatMap(\n    Transformer&lt;? super T, ? extends Loggable&lt;? extends U&gt;&gt; transformer) {\n  Loggable&lt;? extends U&gt; newLoggable = transformer.transform(this.value);\n  return new Loggable&lt;&gt;(\n    newLoggable.value,\n    this.log + newLoggable.log\n  );\n}\n</code></pre></p> </li> </ol>"},{"location":"35-logger/#usage-example","title":"Usage Example","text":"<pre><code>Loggable&lt;Integer&gt; result = Loggable.of(4)\n    .flatMap(x -&gt; new Loggable&lt;&gt;(x + 1, \"Added 1; \"))\n    .flatMap(x -&gt; new Loggable&lt;&gt;(x * 2, \"Multiplied by 2; \"));\n// value: 10\n// log: \"Added 1; Multiplied by 2; \"\n</code></pre>"},{"location":"35-logger/#benefits","title":"Benefits","text":"<ol> <li> <p>Side-effect Free:</p> <ul> <li>Pure functional approach</li> <li>No global state modification</li> <li>Composable operations</li> </ul> </li> <li> <p>Operation Tracking:</p> <ul> <li>Maintains operation history</li> <li>Debugging aid</li> <li>Audit trail</li> </ul> </li> <li> <p>Type Safety:</p> <ul> <li>Generic implementation</li> <li>Compile-time type checking</li> <li>Safe operation chaining</li> </ul> </li> </ol>"},{"location":"35-logger/#best-practices","title":"Best Practices","text":"<ul> <li>Use meaningful log messages</li> <li>Chain operations functionally</li> <li>Keep logs concise</li> <li>Consider performance</li> <li>Handle null cases</li> <li>Document logging behavior</li> </ul>"},{"location":"36-monad/","title":"Monad Summary","text":""},{"location":"36-monad/#monad-concept","title":"Monad Concept","text":"<ul> <li>Container type with specific behavior rules</li> <li>Supports sequential operations</li> <li>Maintains computational context</li> <li>Example:   <pre><code>interface Monad&lt;T&gt; {\n  &lt;U&gt; Monad&lt;U&gt; flatMap(Transformer&lt;? super T, \n      ? extends Monad&lt;? extends U&gt;&gt; transformer);\n\n  static &lt;T&gt; Monad&lt;T&gt; of(T value);\n}\n</code></pre></li> </ul>"},{"location":"36-monad/#monad-laws","title":"Monad Laws","text":"<ol> <li> <p>Left Identity:    <pre><code>Monad.of(x).flatMap(f) == f.transform(x)\n</code></pre></p> </li> <li> <p>Right Identity:    <pre><code>monad.flatMap(x -&gt; Monad.of(x)) == monad\n</code></pre></p> </li> <li> <p>Associativity:    <pre><code>monad.flatMap(f).flatMap(g) == \n  monad.flatMap(x -&gt; f.transform(x).flatMap(g))\n</code></pre></p> </li> </ol>"},{"location":"36-monad/#examples-of-monads","title":"Examples of Monads","text":"<ol> <li> <p>Maybe Monad:    <pre><code>Maybe&lt;Integer&gt; result = Maybe.some(4)\n    .flatMap(x -&gt; Maybe.some(x + 1))\n    .flatMap(x -&gt; Maybe.some(x * 2));\n</code></pre></p> </li> <li> <p>Lazy Monad:    <pre><code>Lazy&lt;Integer&gt; result = Lazy.of(() -&gt; compute())\n    .flatMap(x -&gt; Lazy.of(() -&gt; x + 1));\n</code></pre></p> </li> <li> <p>Loggable Monad:    <pre><code>Loggable&lt;Integer&gt; result = Loggable.of(4)\n    .flatMap(x -&gt; new Loggable&lt;&gt;(x + 1, \"Added 1\"));\n</code></pre></p> </li> </ol>"},{"location":"36-monad/#benefits-of-monads","title":"Benefits of Monads","text":"<ol> <li> <p>Composition:</p> <ul> <li>Chain operations</li> <li>Maintain context</li> <li>Handle side effects</li> </ul> </li> <li> <p>Abstraction:</p> <ul> <li>Hide implementation details</li> <li>Consistent interface</li> <li>Reusable patterns</li> </ul> </li> <li> <p>Safety:</p> <ul> <li>Type safety</li> <li>Controlled effects</li> <li>Predictable behavior</li> </ul> </li> </ol>"},{"location":"36-monad/#best-practices","title":"Best Practices","text":"<ul> <li>Follow monad laws</li> <li>Document behavior</li> <li>Use meaningful names</li> <li>Keep operations pure</li> <li>Handle edge cases</li> <li>Test all paths</li> </ul>"},{"location":"37-parallel/","title":"Parallel Streams Summary","text":""},{"location":"37-parallel/#parallel-processing-concept","title":"Parallel Processing Concept","text":"<ul> <li>Concurrent execution of tasks</li> <li>Uses multiple threads/cores</li> <li>Automatic work distribution</li> <li>Example:   <pre><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nnumbers.parallelStream()\n       .map(x -&gt; x * 2)\n       .collect(Collectors.toList());\n</code></pre></li> </ul>"},{"location":"37-parallel/#creating-parallel-streams","title":"Creating Parallel Streams","text":"<ol> <li> <p>From Collection:    <pre><code>// Method 1\nlist.parallelStream()\n\n// Method 2\nlist.stream().parallel()\n</code></pre></p> </li> <li> <p>From Arrays:    <pre><code>Arrays.stream(array).parallel()\n</code></pre></p> </li> </ol>"},{"location":"37-parallel/#parallel-stream-operations","title":"Parallel Stream Operations","text":"<ol> <li> <p>Stateless Operations (Safe):</p> <ul> <li>map</li> <li>filter</li> <li>flatMap    <pre><code>stream.parallel()\n      .filter(x -&gt; x &gt; 0)\n      .map(x -&gt; x * 2)\n</code></pre></li> </ul> </li> <li> <p>Stateful Operations (Careful):</p> <ul> <li>sorted</li> <li>distinct</li> <li>limit    <pre><code>stream.parallel()\n      .sorted()      // may impact performance\n      .distinct()    // requires coordination\n</code></pre></li> </ul> </li> </ol>"},{"location":"37-parallel/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>When to Use:</p> <ul> <li>Large data sets</li> <li>Computationally intensive</li> <li>Independent operations</li> <li>Multiple cores available</li> </ul> </li> <li> <p>When to Avoid:</p> <ul> <li>Small data sets</li> <li>IO-bound operations</li> <li>Operations with dependencies</li> <li>Single core systems</li> </ul> </li> </ol>"},{"location":"37-parallel/#thread-safety","title":"Thread Safety","text":"<ol> <li> <p>Safe Operations:    <pre><code>// Thread-safe reduction\nint sum = numbers.parallelStream()\n                .reduce(0, Integer::sum);\n</code></pre></p> </li> <li> <p>Unsafe Operations:    <pre><code>// Not thread-safe\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nstream.parallel()\n      .forEach(list::add);  // Don't do this!\n</code></pre></p> </li> </ol>"},{"location":"37-parallel/#best-practices","title":"Best Practices","text":"<ul> <li>Use thread-safe collections</li> <li>Avoid stateful operations</li> <li>Consider ordering requirements</li> <li>Test performance gains</li> <li>Handle exceptions properly</li> <li>Use appropriate collectors</li> <li>Example:   ```java   // Good practice   List result = numbers.parallelStream()       .map(x -&gt; expensiveOperation(x))       .collect(Collectors.toList());"},{"location":"38-thread/","title":"Threads Summary","text":""},{"location":"38-thread/#thread-concept","title":"Thread Concept","text":"<ul> <li>Unit of program execution</li> <li>Independent sequence of operations</li> <li>Can run concurrently</li> <li>Example:   <pre><code>Thread t = new Thread(() -&gt; {\n  System.out.println(\"Running in new thread\");\n});\nt.start();\n</code></pre></li> </ul>"},{"location":"38-thread/#creating-threads","title":"Creating Threads","text":"<ol> <li> <p>Using Runnable:    <pre><code>Runnable task = () -&gt; {\n  // task code here\n};\nThread thread = new Thread(task);\nthread.start();\n</code></pre></p> </li> <li> <p>Extending Thread:    <pre><code>class MyThread extends Thread {\n  public void run() {\n    // task code here\n  }\n}\nnew MyThread().start();\n</code></pre></p> </li> </ol>"},{"location":"38-thread/#thread-states","title":"Thread States","text":"<ul> <li>NEW: Created but not yet started</li> <li>RUNNABLE: Executing or ready to execute</li> <li>BLOCKED: Waiting for monitor lock</li> <li>WAITING: Waiting indefinitely</li> <li>TIMED_WAITING: Waiting for specified time</li> <li>TERMINATED: Completed execution</li> </ul>"},{"location":"38-thread/#thread-operations","title":"Thread Operations","text":"<ol> <li> <p>Basic Operations:    <pre><code>thread.start();     // start thread\nthread.join();      // wait for completion\nthread.sleep(1000); // pause execution\nthread.interrupt(); // interrupt thread\n</code></pre></p> </li> <li> <p>Thread Information:    <pre><code>Thread.currentThread().getName();    // get name\nThread.currentThread().isAlive();    // check if alive\nThread.currentThread().setPriority(5); // set priority\n</code></pre></p> </li> </ol>"},{"location":"38-thread/#thread-safety-issues","title":"Thread Safety Issues","text":"<ol> <li> <p>Race Conditions:    <pre><code>// Unsafe\ncounter++;  // not atomic\n\n// Safe\nsynchronized(lock) {\n  counter++;\n}\n</code></pre></p> </li> <li> <p>Visibility Problems:    <pre><code>// May have visibility issues\nboolean flag = false;\n\n// Guaranteed visibility\nvolatile boolean flag = false;\n</code></pre></p> </li> </ol>"},{"location":"38-thread/#best-practices","title":"Best Practices","text":"<ul> <li>Use thread pools when possible</li> <li>Handle interruptions properly</li> <li>Avoid shared mutable state</li> <li>Use proper synchronization</li> <li>Document thread safety</li> <li>Test concurrent behavior</li> <li>Example:   ```java   try {     thread.join();   } catch (InterruptedException e) {     Thread.currentThread().interrupt();     // handle interruption   }</li> </ul>"},{"location":"39-async/","title":"Asynchronous Programming Summary","text":""},{"location":"39-async/#completablefuture-concept","title":"CompletableFuture Concept","text":"<ul> <li>Represents a future result</li> <li>Supports non-blocking operations</li> <li>Enables asynchronous programming</li> <li>Example:   <pre><code>CompletableFuture&lt;String&gt; future = \n    CompletableFuture.supplyAsync(() -&gt; \n        expensiveOperation());\n</code></pre></li> </ul>"},{"location":"39-async/#creating-completablefuture","title":"Creating CompletableFuture","text":"<ol> <li> <p>Static Factory Methods:    <pre><code>// Complete future\nCompletableFuture.completedFuture(value);\n\n// Run async task\nCompletableFuture.runAsync(() -&gt; task());\n\n// Supply async result\nCompletableFuture.supplyAsync(() -&gt; compute());\n</code></pre></p> </li> <li> <p>Multiple Futures:    <pre><code>CompletableFuture&lt;Void&gt; all = \n    CompletableFuture.allOf(future1, future2);\n\nCompletableFuture&lt;Object&gt; any = \n    CompletableFuture.anyOf(future1, future2);\n</code></pre></p> </li> </ol>"},{"location":"39-async/#chaining-operations","title":"Chaining Operations","text":"<ol> <li> <p>Transformations:    <pre><code>future.thenApply(x -&gt; x * 2)        // map\n      .thenCompose(x -&gt; compute(x))  // flatMap\n      .thenCombine(other, (x,y) -&gt; x + y);\n</code></pre></p> </li> <li> <p>Side Effects:    <pre><code>future.thenAccept(System.out::println)  // consumer\n      .thenRun(() -&gt; cleanup());        // runnable\n</code></pre></p> </li> </ol>"},{"location":"39-async/#exception-handling","title":"Exception Handling","text":"<pre><code>future.exceptionally(ex -&gt; {\n    System.err.println(ex);\n    return defaultValue;\n  })\n  .handle((result, ex) -&gt; {\n    if (ex != null) {\n      return handleError(ex);\n    }\n    return result;\n  });\n</code></pre>"},{"location":"39-async/#async-vs-sync-methods","title":"Async vs Sync Methods","text":"<ol> <li> <p>Async Methods:    <pre><code>// Executes in different thread\nfuture.thenApplyAsync(x -&gt; process(x));\nfuture.thenComposeAsync(x -&gt; compute(x));\nfuture.thenCombineAsync(other, (x,y) -&gt; combine(x,y));\n</code></pre></p> </li> <li> <p>Sync Methods:    <pre><code>// Executes in same thread\nfuture.thenApply(x -&gt; process(x));\nfuture.thenCompose(x -&gt; compute(x));\nfuture.thenCombine(other, (x,y) -&gt; combine(x,y));\n</code></pre></p> </li> </ol>"},{"location":"39-async/#best-practices","title":"Best Practices","text":"<ul> <li>Use async operations for I/O</li> <li>Handle exceptions properly</li> <li>Don't block unnecessarily</li> <li>Consider thread pools</li> <li>Chain operations efficiently</li> <li>Test async behavior</li> <li>Example:   ```java   CompletableFuture result =        CompletableFuture.supplyAsync(() -&gt; readFile())           .thenApplyAsync(content -&gt; process(content))           .exceptionally(ex -&gt; handleError(ex));"},{"location":"40-forkjoin/","title":"Fork and Join Summary","text":""},{"location":"40-forkjoin/#forkjoin-framework-concept","title":"Fork/Join Framework Concept","text":"<ul> <li>Divide-and-conquer parallelism</li> <li>Work-stealing algorithm</li> <li>Recursive task decomposition</li> <li>Example:   <pre><code>class SumTask extends RecursiveTask&lt;Long&gt; {\n  private final long[] array;\n  private final int start;\n  private final int end;\n\n  @Override\n  protected Long compute() {\n    if (end - start &lt;= THRESHOLD) {\n      return computeDirectly();\n    }\n    int mid = (start + end) / 2;\n    SumTask left = new SumTask(array, start, mid);\n    SumTask right = new SumTask(array, mid, end);\n    left.fork();\n    return right.compute() + left.join();\n  }\n}\n</code></pre></li> </ul>"},{"location":"40-forkjoin/#forkjoinpool","title":"ForkJoinPool","text":"<ul> <li>Thread pool for fork/join tasks</li> <li>Work-stealing deque</li> <li>Automatic load balancing</li> <li>Example:   <pre><code>ForkJoinPool pool = new ForkJoinPool();\nLong result = pool.invoke(new SumTask(array, 0, array.length));\n</code></pre></li> </ul>"},{"location":"40-forkjoin/#recursivetask-operations","title":"RecursiveTask Operations","text":"<ol> <li> <p>Fork:    <pre><code>leftTask.fork();  // submit task for async execution\n</code></pre></p> </li> <li> <p>Join:    <pre><code>Long result = leftTask.join();  // wait for result\n</code></pre></p> </li> <li> <p>Compute:    <pre><code>Long result = rightTask.compute();  // execute directly\n</code></pre></p> </li> </ol>"},{"location":"40-forkjoin/#forkjoin-patterns","title":"Fork/Join Patterns","text":"<ol> <li> <p>Good Pattern:    <pre><code>left.fork();\nright.compute();  // compute one side directly\nleft.join();\n</code></pre></p> </li> <li> <p>Better Pattern:    <pre><code>left.fork();\nLong rightResult = right.compute();\nLong leftResult = left.join();\nreturn leftResult + rightResult;\n</code></pre></p> </li> </ol>"},{"location":"40-forkjoin/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>Task Granularity:</p> <ul> <li>Too small: overhead dominates</li> <li>Too large: poor parallelism</li> <li>Use threshold to switch to sequential    <pre><code>if (end - start &lt;= THRESHOLD) {\n  return computeSequentially();\n}\n</code></pre></li> </ul> </li> <li> <p>Work Stealing:</p> <ul> <li>Idle threads steal work</li> <li>Balances load automatically</li> <li>Efficient for uneven tasks</li> </ul> </li> </ol>"},{"location":"40-forkjoin/#best-practices","title":"Best Practices","text":"<ul> <li>Choose appropriate threshold</li> <li>Avoid synchronized methods</li> <li>Minimize task dependencies</li> <li>Handle exceptions properly</li> <li>Profile performance</li> <li>Test with different sizes</li> <li>Example:   ```java   class ParallelTask extends RecursiveTask {     @Override     protected Result compute() {       if (size &lt;= THRESHOLD) {         return computeSequentially();       }       ParallelTask left = new ParallelTask(leftPart);       ParallelTask right = new ParallelTask(rightPart);       left.fork();       Result rightResult = right.compute();       Result leftResult = left.join();       return combine(leftResult, rightResult);     }   }"},{"location":"41-package/","title":"Java Packages","text":""},{"location":"41-package/#package-concept","title":"Package Concept","text":"<ul> <li>Packages group related classes together</li> <li>Provide an abstraction barrier for code organization</li> <li>Help manage the namespace and avoid naming conflicts</li> <li>Enable access control between different parts of code</li> </ul>"},{"location":"41-package/#package-naming-convention","title":"Package Naming Convention","text":"<ul> <li>Hierarchical dot notation (e.g., <code>com.google.common.math</code>, <code>java.io</code>)</li> <li>Usually follows reverse domain name of the organization   <pre><code>com.company.project.module\n</code></pre></li> <li>Prevents package name collisions across different organizations</li> </ul>"},{"location":"41-package/#package-structure-and-file-system","title":"Package Structure and File System","text":"<ul> <li>Java maps package names to directory hierarchy</li> <li>Class <code>a.b.C</code> is looked for in path <code>a/b/C.class</code></li> <li>Example:   <pre><code>package com.example.project;\n\npublic class MyClass { ... }\n\n// This class would be stored in: com/example/project/MyClass.class\n</code></pre></li> </ul>"},{"location":"41-package/#default-package","title":"Default Package","text":"<ul> <li>Classes without a package declaration belong to the \"default\" package</li> <li>All classes in the same directory without package declarations share this namespace</li> </ul>"},{"location":"41-package/#package-access-control","title":"Package Access Control","text":"Modifier Class Package Subclass (same pkg) Subclass (diff pkg) World public \u2705 \u2705 \u2705 \u2705 \u2705 protected \u2705 \u2705 \u2705 \u2705 \u274c (no modifier) \u2705 \u2705 \u2705 \u274c \u274c private \u2705 \u274c \u274c \u274c \u274c"},{"location":"41-package/#example-of-protected-access","title":"Example of Protected Access","text":"<pre><code>// In file A.java (package com.example)\npackage com.example;\n\npublic class A {\n    protected int x;  // protected data field\n}\n</code></pre> <pre><code>// In file B.java (package com.example)\npackage com.example;\n\npublic class B {\n    public void accessX() {\n        A a = new A();\n        a.x = 10;  // Accessible: same package\n    }\n}\n</code></pre> <pre><code>// In file C.java (package com.example.other)\npackage com.example.other;\n\nimport com.example.A;\n\npublic class C extends A {\n    public void accessX() {\n        x = 20;  // Accessible: subclass from different package\n    }\n}\n</code></pre> <pre><code>// In file D.java (package com.example.other)\npackage com.example.other;\n\nimport com.example.A;\n\npublic class D {\n    public void accessX() {\n        A a = new A();\n        // a.x = 30;  // ERROR: Cannot access protected field from unrelated class\n    }\n}\n</code></pre>"},{"location":"41-package/#creating-and-using-packages","title":"Creating and Using Packages","text":"<ul> <li> <p>Declare package as the first line in your Java file:   <pre><code>package cs2030s.fp;\n\npublic interface BooleanCondition&lt;T&gt; {\n    boolean test(T t);\n}\n</code></pre></p> </li> <li> <p>To use classes from other packages:   <pre><code>// Option 1: Full qualification\ncs2030s.fp.BooleanCondition&lt;Integer&gt; isEven = x -&gt; x % 2 == 0;\n\n// Option 2: Import and use\nimport cs2030s.fp.BooleanCondition;\nBooleanCondition&lt;Integer&gt; isEven = x -&gt; x % 2 == 0;\n</code></pre></p> </li> </ul>"},{"location":"41-package/#best-practices","title":"Best Practices","text":"<ul> <li>Organize related classes in the same package</li> <li>Use hierarchical packages for large projects</li> <li>Always declare packages in production code</li> <li>Use meaningful package names that reflect code purpose</li> <li>Keep package structure aligned with project architecture</li> </ul>"}]}